<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
<meta name="referrer" content="no-referrer" />
<meta http-equiv="Content-Security-Policy" ontent="upgrade-insecure-requests">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zephon.eu.org","root":"/blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java基础查漏补缺 日期相关 Date">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础查漏补缺">
<meta property="og:url" content="http://www.zephon.eu.org/blog/2022/07/27/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/index.html">
<meta property="og:site_name" content="Zephon Blog">
<meta property="og:description" content="Java基础查漏补缺 日期相关 Date">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/28597493/1658636189574-e3f17125-aa7c-4c3b-9ab3-2c12de04b431.png#clientId=u9e01c26e-c4d2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=447&amp;id=u73379749&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=893&amp;originWidth=1798&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=995233&amp;status=done&amp;style=none&amp;taskId=u9bd118f7-8b29-498d-ad53-3d298fa3579&amp;title=&amp;width=899">
<meta property="article:published_time" content="2022-07-27T02:13:11.000Z">
<meta property="article:modified_time" content="2023-07-20T08:32:51.098Z">
<meta property="article:author" content="Zephon">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/png/28597493/1658636189574-e3f17125-aa7c-4c3b-9ab3-2c12de04b431.png#clientId=u9e01c26e-c4d2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=447&amp;id=u73379749&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=893&amp;originWidth=1798&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=995233&amp;status=done&amp;style=none&amp;taskId=u9bd118f7-8b29-498d-ad53-3d298fa3579&amp;title=&amp;width=899">

<link rel="canonical" href="http://www.zephon.eu.org/blog/2022/07/27/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础查漏补缺 | Zephon Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?697784f78fd83128cc519aedf69e3017";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband">
	<a target="_blank" rel="noopener" href="https://github.com/Zephon-H" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zephon Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-download">

    <a href="/blog/download/" rel="section"><i class="fa fa-download fa-fw"></i>下载</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.zephon.eu.org/blog/2022/07/27/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar1.gif">
      <meta itemprop="name" content="Zephon">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zephon Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础查漏补缺
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-27 10:13:11" itemprop="dateCreated datePublished" datetime="2022-07-27T10:13:11+08:00">2022-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-20 16:32:51" itemprop="dateModified" datetime="2023-07-20T16:32:51+08:00">2023-07-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>41k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>37 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="java基础查漏补缺">Java基础查漏补缺</h1>
<h2 id="日期相关">日期相关</h2>
<h3 id="date">Date</h3>
<h4 id="java.util.date">java.util.Date</h4>
<p>toString()输出形式是形如：Sat Jul 23 17:22:37 CST 2022的，包括到具体时间</p>
<h5 id="两个常用构造器其它已过时">两个常用构造器(其它已过时)：</h5>
<ol type="1">
<li><p>空参构造器，默认是当前日期时间 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d); <span class="comment">// Sat Jul 23 17:22:37 CST 2022</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>带参构造器，传入一个长整型(时间戳) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">System.out.println(d); <span class="comment">// Sat Jul 23 17:23:59 CST 2022</span></span><br></pre></td></tr></table></figure> ##### 常用方法</p></li>
<li><p>日期转时间戳<strong>getTime()</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d.getTime()); <span class="comment">// 1658568326143</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="java.sql.date">java.sql.Date</h4>
<p>继承自java.util.Date，toString()输出形式形如：2022-07-23，只有日期，没有具体时间</p>
<h5 id="构造器">构造器</h5>
<p>传入一个常整型参数(时间戳) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">System.out.println(d); <span class="comment">// 2022-07-23</span></span><br></pre></td></tr></table></figure></p>
<h5 id="常用方法">常用方法</h5>
<p>与java.util.date一样 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date d = <span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">System.out.println(d.getTime()); <span class="comment">// 1658568525790</span></span><br></pre></td></tr></table></figure></p>
<h4 id="java.text.simpledateformat">java.text.SimpleDateFormat</h4>
<p>作用是将Date类格式化输出或将指定格式字符串转成Date类</p>
<h5 id="两个构造器">两个构造器</h5>
<ol type="1">
<li><p>空参构造器 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(sdf.format(date)); <span class="comment">// 22-7-23 下午5:31</span></span><br></pre></td></tr></table></figure> 默认格式是"22-7-23 下午5:31"</p></li>
<li><p>带参构造器，指定格式对Date进行格式化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(sdf.format(date)); <span class="comment">// 2022-07-23 05:33:08</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h5 id="常用方法-1">常用方法</h5>
<ol type="1">
<li>format</li>
</ol>
<p>对日期进行格式化 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(sdf.format(date)); <span class="comment">// 2022-07-23 05:33:08</span></span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>parse</li>
</ol>
<p>将符合格式的字符串解析成Date类，如果字符串不满足格式则抛出异常 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">Date date = sdf.parse(<span class="string">&quot;2022-07-25 03:22:01&quot;</span>);</span><br><span class="line">System.out.println(date); <span class="comment">// Mon Jul 25 03:22:01 CST 2022</span></span><br></pre></td></tr></table></figure></p>
<h4 id="java.util.calendar">java.util.Calendar</h4>
<p>Calendar是一个抽象类，主要用于完成日期字段之间相互操作的功能</p>
<h5 id="获取实例的方法">获取实例的方法</h5>
<ol type="1">
<li><p>调用静态方法Calendar._getInstance_(); 更常用，好记 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br></pre></td></tr></table></figure></p></li>
<li><p>实例化具体子类new GregorianCalendar() <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = <span class="keyword">new</span> GregorianCalendar();</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h5 id="常用方法-2">常用方法</h5>
<ol type="1">
<li>get()</li>
</ol>
<p>输入一个int型参数，实际使用中常用自带常量 :::success 获取月份时：一月是0，二月是1，以此类推 获取星期时：周日是1，周二是2，... ::: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); <span class="comment">// 23(本月第23天)</span></span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>set()</li>
</ol>
<p>修改对应的属于 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_WEEK)); <span class="comment">// 7</span></span><br><span class="line">calendar.set(Calendar.DAY_OF_WEEK, <span class="number">2</span>);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_WEEK)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<ol start="3" type="1">
<li><p>add()：添加指定类型数值 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); <span class="comment">// 204</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_YEAR, <span class="number">3</span>);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR)); <span class="comment">// 207</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>getTime()：获取当前时间对应的Date类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = calendar.getTime();</span><br><span class="line">System.out.println(date); <span class="comment">// Sun Jul 24 10:47:42 CST 2022</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>setTime()：设置当前日期 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">calendar.setTime(date);</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h4 id="jdk8新增的常用日期时间api吸收的joda-time的">jdk8新增的常用日期时间API(吸收的Joda-Time的)</h4>
<h5 id="本地日期localdate">本地日期LocalDate</h5>
<h6 id="实例化">实例化</h6>
<ol type="1">
<li>now()：根据当前日期创建对象</li>
<li>of(int year, int month, int dayOfMonth)：根据指定日期创建对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld1 = LocalDate.now();</span><br><span class="line">LocalDate ld2 = LocalDate.of(<span class="number">2022</span>, <span class="number">1</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="常用方法-3">常用方法</h6>
<table>
<thead>
<tr class="header">
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getDayOfMonth()/getDayOfYear()/getDayOfWeek()</td>
<td>获取日期对应本月/年/周第几天</td>
</tr>
<tr class="even">
<td>withDayOfMonth()/withDayOfYear()</td>
<td>设置当前是本月第几天或本年第几天</td>
</tr>
<tr class="odd">
<td>getMonth()</td>
<td>获取月份(如：JULY)</td>
</tr>
<tr class="even">
<td>getMonthValue()</td>
<td>获取月份值(如：7)</td>
</tr>
<tr class="odd">
<td>getYear()</td>
<td>获取年份(如：2022)</td>
</tr>
<tr class="even">
<td>plusDays()/plusWeeks()/plusMonths()/plusYears()</td>
<td>向当前日期增加指定天、周、月、年</td>
</tr>
<tr class="odd">
<td>minusDays()/minusWeeks()/minusMonths()/minusYears()</td>
<td>从当前日期减去指定天、周、月、年</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">System.out.println(localDate); <span class="comment">// 2022-07-24</span></span><br><span class="line">System.out.println(localDate.getDayOfMonth()); <span class="comment">// 24</span></span><br><span class="line">System.out.println(localDate.getDayOfYear());  <span class="comment">// 205</span></span><br><span class="line">System.out.println(localDate.getDayOfWeek());  <span class="comment">// SUNDAY</span></span><br><span class="line">System.out.println(localDate.getMonth());      <span class="comment">// JULY</span></span><br><span class="line">System.out.println(localDate.getMonthValue()); <span class="comment">// 7</span></span><br><span class="line">System.out.println(localDate.getYear());       <span class="comment">// 2022</span></span><br><span class="line">System.out.println(localDate.plusDays(<span class="number">1</span>));         <span class="comment">// 2022-07-25</span></span><br><span class="line">System.out.println(localDate.plusWeeks(<span class="number">1</span>));       <span class="comment">// 2022-07-31</span></span><br><span class="line">System.out.println(localDate.plusMonths(<span class="number">1</span>));     <span class="comment">// 2022-08-24</span></span><br><span class="line">System.out.println(localDate.plusYears(<span class="number">1</span>));        <span class="comment">// 2023-07-24</span></span><br><span class="line">System.out.println(localDate.minusDays(<span class="number">1</span>));     <span class="comment">// 2022-07-23</span></span><br><span class="line">System.out.println(localDate.minusWeeks(<span class="number">1</span>));   <span class="comment">// 2022-07-17</span></span><br><span class="line">System.out.println(localDate.minusMonths(<span class="number">1</span>)); <span class="comment">// 2022-06-24</span></span><br><span class="line">System.out.println(localDate.minusYears(<span class="number">1</span>));    <span class="comment">// 2021-07-24</span></span><br></pre></td></tr></table></figure>
<h5 id="本地时间localtime">本地时间LocalTime</h5>
<h6 id="实例化-1">实例化</h6>
<p>与LocalDate一样类似，其中LocalTime.of(int hour, int minute, int second, int nanoOfSecond) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalTime lt1 = LocalTime.now();</span><br><span class="line">LocalTime lt2 = LocalTime.of(<span class="number">10</span>, <span class="number">25</span>, <span class="number">3</span>, <span class="number">100</span>);</span><br><span class="line">System.out.println(lt1); <span class="comment">// 11:18:58.740</span></span><br><span class="line">System.out.println(lt2); <span class="comment">// 10:25:03.000000100</span></span><br></pre></td></tr></table></figure></p>
<h6 id="常用方法-4">常用方法</h6>
<table>
<thead>
<tr class="header">
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>getHour()/getMinute()/getSecond()</td>
<td>获取时/分/秒</td>
</tr>
<tr class="even">
<td>plusHours()/plusMinutes()/plusSeconds()</td>
<td>在当前时间基础上增加时/分/秒</td>
</tr>
<tr class="odd">
<td>minusHours()/minusMinutes()/minusSeconds()</td>
<td>在当前时间基础上减去时/分/秒</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime lt1 = LocalTime.now();</span><br><span class="line">System.out.println(lt1);            <span class="comment">// 11:22:38.998</span></span><br><span class="line">System.out.println(lt1.getHour());  <span class="comment">// 11</span></span><br><span class="line">System.out.println(lt1.getMinute());<span class="comment">// 22</span></span><br><span class="line">System.out.println(lt1.getSecond());<span class="comment">// 38</span></span><br><span class="line">System.out.println(lt1.plusHours(<span class="number">1</span>));          <span class="comment">// 12:22:38.998</span></span><br><span class="line">System.out.println(lt1.plusMinutes(<span class="number">1</span>));      <span class="comment">// 11:23:38.998</span></span><br><span class="line">System.out.println(lt1.plusSeconds(<span class="number">1</span>));      <span class="comment">// 11:22:39.998</span></span><br><span class="line">System.out.println(lt1.minusHours(<span class="number">1</span>));     <span class="comment">// 10:22:38.998</span></span><br><span class="line">System.out.println(lt1.minusMinutes(<span class="number">1</span>)); <span class="comment">// 11:21:38.998</span></span><br><span class="line">System.out.println(lt1.minusSeconds(<span class="number">1</span>)); <span class="comment">// 11:22:37.998</span></span><br></pre></td></tr></table></figure>
<h5 id="本地日期时间localdatetime">本地日期时间LocalDateTime</h5>
<p>实际就是LocalDate与LocalTime的综合</p>
<h5 id="瞬时instant">瞬时Instant</h5>
<p>类似于java.util.Date</p>
<h6 id="实例化-2">实例化</h6>
<ol type="1">
<li>now()：返回本初子午线上当前时间Instant类的对象，中国时间需要加8小时才行</li>
<li>ofEpochMilli()：返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = Instant.now();</span><br><span class="line">System.out.println(instant); <span class="comment">// 2022-07-24T03:34:25.634Z</span></span><br><span class="line">instant = Instant.ofEpochMilli(System.currentTimeMillis());</span><br><span class="line">System.out.println(instant); <span class="comment">// 2022-07-24T03:34:25.692Z</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="常用方法-5">常用方法</h6>
<ol type="1">
<li>atOffset(ZoneOffset offset)：结合即时偏移</li>
<li>toEpochMilli()：返回对应时间戳 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(instant); <span class="comment">// 2022-07-24T03:38:56.132Z</span></span><br><span class="line">System.out.println(instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>))); <span class="comment">// 2022-07-24T11:38:56.132+08:00</span></span><br><span class="line">System.out.println(instant.toEpochMilli()); <span class="comment">// 1658633936132</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="日期时间格式化与解析java.time.format.datetimeformatter">日期时间格式化与解析java.time.format.DateTimeFormatter</h5>
<h6 id="实例化-3">实例化</h6>
<ol type="1">
<li>预定义的标准格式：形如DateTimeFormatter._ISO_LOCAL_DATE_TIME;_</li>
<li>本地化相关的格式：形如DateTimeFormatter._ofLocalizedDate_(FormatStyle._LONG_);</li>
<li>自定义格式：形如DateTimeFormatter._ofPattern_("yyyy-MM-dd hh:mm:ss"); <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);    <span class="comment">// 2022-07-24T11:47:07.662</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">System.out.println(formatter.format(ldt));  <span class="comment">// 2022-07-24T11:47:07.662</span></span><br><span class="line">DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG);</span><br><span class="line">System.out.println(formatter1.format(ldt)); <span class="comment">// 2022年7月24日</span></span><br><span class="line">DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(formatter2.format(ldt)); <span class="comment">// 2022-07-24 11:47:07</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="常用方法-6">常用方法</h6>
<ol type="1">
<li>格式化format</li>
<li>解析parse <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(formatter2.format(ldt)); <span class="comment">// 2022-07-24 11:47:07</span></span><br><span class="line">TemporalAccessor parse = formatter2.parse(<span class="string">&quot;2022-01-11 12:32:03&quot;</span>);</span><br><span class="line">System.out.println(parse); <span class="comment">// &#123;SecondOfMinute=3, HourOfAmPm=0, MinuteOfHour=32, NanoOfSecond=0, MilliOfSecond=0, MicroOfSecond=0&#125;,ISO resolved to 2022-01-11</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="其它">其它</h5>
<ul>
<li>ZoneId</li>
<li>ZonedDateTime</li>
<li>Clock</li>
<li>Duration</li>
<li>Period</li>
<li>TemporalAdjuster</li>
<li>TemporalAdjusters</li>
</ul>
<figure>
<img src="https://cdn.nlark.com/yuque/0/2022/png/28597493/1658636189574-e3f17125-aa7c-4c3b-9ab3-2c12de04b431.png#clientId=u9e01c26e-c4d2-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=447&amp;id=u73379749&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=893&amp;originWidth=1798&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=995233&amp;status=done&amp;style=none&amp;taskId=u9bd118f7-8b29-498d-ad53-3d298fa3579&amp;title=&amp;width=899" alt="image.png" /><figcaption>image.png</figcaption>
</figure>
<h2 id="枚举类">枚举类</h2>
<p>使用enum关键字来定义枚举类，则定义的类的父类实际上是Enum类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供枚举类对象</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>), <span class="comment">// 用逗号隔开</span></span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    String name;</span><br><span class="line">    Season(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 也能实现接口： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> <span class="keyword">implements</span> <span class="title">info</span></span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天重写&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;夏天重写&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    String name;</span><br><span class="line">    Season(String name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;整体重写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 常用方法：</p>
<ol type="1">
<li>values()方法：返回枚举类型的对象数组，可以方便遍历枚举类对象</li>
<li>valueOf(String str)方法：</li>
<li>toString()方法：返回当前枚举类对象常量名称，如SUMMER <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Arrays.toString(Season.SPRING.values())); <span class="comment">// SPRING</span></span><br><span class="line">System.out.println(Season.valueOf(<span class="string">&quot;SUMMER&quot;</span>)); <span class="comment">// 找到SUMMER()对象</span></span><br><span class="line">System.out.println(Season.SPRING); <span class="comment">// [SPRING, SUMMER, AUTUMN, WINTER]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="注解">注解</h2>
<h3 id="jdk内置的三个基本注解">jdk内置的三个基本注解</h3>
<ol type="1">
<li><span class="citation" data-cites="Override">@Override</span>：限定重写父类方法，只能用于方法</li>
<li><span class="citation" data-cites="Deprecated">@Deprecated</span>：用于表示所修饰的元素已过时</li>
<li><span class="citation" data-cites="SuppressWarnings">@SuppressWarnings</span>：抑制编译器警告</li>
</ol>
<h3 id="自定义注解">自定义注解</h3>
<p>参照@SuppressWarnings定义</p>
<ol type="1">
<li>使用@interface声明</li>
<li>内部定义成员
<ul>
<li>成员变量是以无参数方法的形式声明，方法名和返回值定义了成员的名字和类型</li>
<li>如果只有一个参数成员，建议使用参数名为<strong>value</strong></li>
<li>可以在定义成员变量时通过<strong>default</strong>关键字指定初始值</li>
<li>没有成员定义的注解称为<strong>标记</strong>，如@Override；有成员变量的称为<strong>元数据</strong>Annotation <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnno(value = &quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ol>
<h3 id="jdk提供的4种元注解">jdk提供的4种元注解</h3>
<p>元注解：用于修饰其它注解的</p>
<ul>
<li><strong><span class="citation" data-cites="Retention">@Retention</span></strong>
<ul>
<li>用于指定注解的生命周期，包含一个RetentionPolicy类型的成员变量，使用时必须为该value指定值
<ul>
<li><strong>RetentionPolicy.SOURCE</strong>：在源文件有效，编译器直接丢弃这种策略的注解</li>
<li><strong>RetentionPolicy.CLASS</strong>：在class文件中有效，当运行Java程序时，JVM不会保留注解。这是默认值</li>
<li><strong>RetentionPolicy.RUNTIME</strong>：在运行时有效，当运行Java程序时，JVM会保留注解，程序可通过反射获取该注解</li>
</ul></li>
</ul></li>
<li><strong><span class="citation" data-cites="Target">@Target</span></strong>
<ul>
<li>用于指定被修饰的注解能用于修饰哪些程序元素
<ul>
<li>CONSTRUCTOR：用于修饰构造器</li>
<li>FIELD：用于修饰域</li>
<li>LOCAL_VARIABLE：用于修饰局部变量</li>
<li>METHOD：用于修饰方法</li>
<li>PACKAGE：用于修饰包</li>
<li>PARAMETER：用户修饰参数</li>
<li>TYPE：用于修饰类、接口(包括注解类型)或enum声明</li>
</ul></li>
</ul></li>
<li><strong><span class="citation" data-cites="Documented">@Documented</span></strong>
<ul>
<li>用于指定该元注解修饰的注解类会被javadoc提取成文档，默认是不包括注解的(使用时必须将Rentention设为RUNTIME)</li>
</ul></li>
<li><strong><span class="citation" data-cites="Inherited">@Inherited</span></strong>
<ul>
<li>被其修饰的注解将具有<strong>继承性</strong>，即一个类上如果使用的注解是被@Inherited修饰的，则这个类的子类也会自动被这个注解修饰</li>
<li>实际使用较少</li>
</ul></li>
</ul>
<h3 id="jdk8注解新特性">jdk8注解新特性</h3>
<ul>
<li>可重复注解</li>
</ul>
<p>jdk8之前的做法：<strong><span class="citation" data-cites="MyAnnos">@MyAnnos</span>({<span class="citation" data-cites="MyAnno">@MyAnno</span>("aaa"), <span class="citation" data-cites="MyAnno">@MyAnno</span>("bbb")})</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnos&#123;</span><br><span class="line">    MyAnno[] value();</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">@MyAnnos(&#123;@MyAnno(&quot;aaa&quot;), @MyAnno(&quot;bbb&quot;)&#125;)</span></span><br><span class="line">Class A&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> jdk8及之后的写法： 使用<strong><span class="citation" data-cites="Repeatable">@Repeatable</span>(xxx.class)</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 表示保留到运行时阶段，可以通过反射获取</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span> <span class="comment">// 表示只能用在方法上</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnos.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnos&#123;</span><br><span class="line">    MyAnno[] value();</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">@MyAnno(&quot;aaa&quot;)</span></span><br><span class="line"><span class="meta">@MyAnno(&quot;bbb&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>类型注解</li>
</ul>
<p>在@Target中</p>
<ul>
<li>ElementType.TYPE_PARAMETER：可以修饰泛型</li>
<li>ElementType._TYPE_USE_：修饰泛型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 表示保留到运行时阶段，可以通过反射获取</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;@<span class="title">MyAnno</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 表示保留到运行时阶段，可以通过反射获取</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> @MyAnno RuntimeException</span>&#123;</span><br><span class="line">    List&lt;<span class="meta">@MyAnno</span> String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="meta">@MyAnno</span> <span class="keyword">int</span>) <span class="number">10L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="集合">集合</h2>
<h3 id="properties">Properties</h3>
<p>Properties类是Hashtable的子类，用于处理属于文件 特点是：Proberties的key和value都是字符串类型 存取数据时使用：setProperty(String key, String value); getProperty(String key); <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">test</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">p.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.properties&quot;</span>));</span><br><span class="line">System.out.println(p.getProperty(<span class="string">&quot;name&quot;</span>)); <span class="comment">// test</span></span><br><span class="line">System.out.println(p.getProperty(<span class="string">&quot;password&quot;</span>)); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p>
<h2 id="泛型">泛型</h2>
<h3 id="自定义泛型结构泛型类泛型接口泛型方法">自定义泛型结构：泛型类、泛型接口、泛型方法</h3>
<p>如果子类继承带泛型的父类时，指明了泛型，则实例化子类对象时就不需要指明泛型；而如果没有指明，则子类依然是泛型类</p>
<ul>
<li><p>如果有泛型类有多个参数，则可将多个参数一起放在尖括号中，如：&lt;E1, E2, E3&gt;</p></li>
<li><p>泛型类的构造器后面不用加&lt;&gt;，即：public Test()&lt;&gt;{}是错误的，应该直接public Test(){}</p></li>
<li><p>泛型不同的引用，不能相互赋值，即：如下代码是错误的： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">list1 = list2; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>静态方法中不能使用类的泛型，但可以使用自己的泛型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;&#125; <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(E e)</span></span>&#123;&#125; <span class="comment">//不报错</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>异常类不能使用泛型</p></li>
<li><p>泛型不能使用new，即不能new E[10]，但可以使用E[] es = (E[])new Object[10];</p></li>
<li><p>泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span>&#123;&#125;<span class="comment">// 最前面的&lt;E&gt;是表示参数arr对应的E是泛型，而不是有E这个类</span></span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">T3</span>&gt;</span>&#123; <span class="comment">// 泛型接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T1 t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="comment">// 泛型类</span></span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line">    T orderT;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String name, <span class="keyword">int</span> id, T t)</span></span>&#123; <span class="comment">// 泛型方法</span></span><br><span class="line">        <span class="keyword">this</span>.orderName = name;</span><br><span class="line">        <span class="keyword">this</span>.orderId = id;</span><br><span class="line">        <span class="keyword">this</span>.orderT = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>通配符：? <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = <span class="keyword">null</span>;</span><br><span class="line">List&lt;Integer&gt; l2 = <span class="keyword">null</span>;</span><br><span class="line">List&lt;?&gt; l3 = <span class="keyword">null</span>; <span class="comment">// 对于List&lt;?&gt;就不能添加数据了，获取数据会得到Object类型数据</span></span><br><span class="line">l3 = l1;</span><br><span class="line">l3 = l2;</span><br></pre></td></tr></table></figure></p></li>
<li><p>有限制条件的通配符</p>
<ul>
<li>上限extends：指定类型必须是继承或本来是某个类(<span class="math inline">\(\le\)</span>)，如：&lt;? extends Number&gt;</li>
<li>下限super：指定类型不能小于操作的类(<span class="math inline">\(\ge\)</span>)，如：&lt;? super Number&gt;</li>
</ul></li>
</ul>
<h2 id="io流">IO流</h2>
<h3 id="java.io.file类">java.io.File类</h3>
<p>表示文件和文件目录路径的抽象表示形式，与平台无关 File类的一个对象，代表一个文件或一个文件目录</p>
<h4 id="实例化-4">实例化</h4>
<ol type="1">
<li>File file = new File(String path);根据路径(相对路径或绝对路径)实例化
<ol type="1">
<li>为避免路径分隔符问题，java提供常量表示：File.separator</li>
</ol></li>
<li>File file = new File(String parent, String child); 如：File file = new File("D:\", "hello.txt");</li>
<li>File file = new File(File parent, String child);</li>
</ol>
<h4 id="常用方法-7">常用方法</h4>
<table>
<thead>
<tr class="header">
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>getAbsoluteFile()</strong></td>
<td>获取绝对路径</td>
</tr>
<tr class="even">
<td>getPath()</td>
<td>获取路径</td>
</tr>
<tr class="odd">
<td>getName()</td>
<td>获取名称</td>
</tr>
<tr class="even">
<td><strong>getParent()</strong></td>
<td>获取上层目录路径，若无返回null</td>
</tr>
<tr class="odd">
<td>length()</td>
<td>获取文件长度(字节数)</td>
</tr>
<tr class="even">
<td>lastModified()</td>
<td>获取最后一次修改时间，时间戳</td>
</tr>
<tr class="odd">
<td>list()</td>
<td>获取指定目录下所有文件或文件目录名称数组</td>
</tr>
<tr class="even">
<td>listFiles()</td>
<td>获取指定目录下所有文件或文件目录File数组</td>
</tr>
<tr class="odd">
<td>boolean renameTo(File dest)</td>
<td>把文件重命名为指定的文件路径，需要源路径存在，目标路径不存在，成功后返回true</td>
</tr>
<tr class="even">
<td><strong>isDirectory()</strong></td>
<td>是否是文件目录</td>
</tr>
<tr class="odd">
<td><strong>isFile()</strong></td>
<td>是否是文件</td>
</tr>
<tr class="even">
<td><strong>exists()</strong></td>
<td>是否存在</td>
</tr>
<tr class="odd">
<td>canRead()</td>
<td>是否可读</td>
</tr>
<tr class="even">
<td>canWrite()</td>
<td>是否可写</td>
</tr>
<tr class="odd">
<td>isHidden()</td>
<td>是否隐藏</td>
</tr>
<tr class="even">
<td><strong>createNewFile()</strong></td>
<td>创建文件，若文件存在则不创建，返回false</td>
</tr>
<tr class="odd">
<td>mkdir()</td>
<td>创建文件目录，若存在则不创建</td>
</tr>
<tr class="even">
<td><strong>mkdirs()</strong></td>
<td>创建文件目录，如果上层文件不存在则一起创建</td>
</tr>
<tr class="odd">
<td>delete()</td>
<td>删除文件或文件夹(文件夹中不能有文件或目录)</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;test.iml&quot;</span>);</span><br><span class="line">System.out.println(file.getAbsoluteFile()); <span class="comment">// D:\Code\JavaCode\test\test.iml</span></span><br><span class="line">System.out.println(file.getPath());         <span class="comment">// test.iml</span></span><br><span class="line">System.out.println(file.getName());         <span class="comment">// test.iml</span></span><br><span class="line">System.out.println(file.getParent());       <span class="comment">// null</span></span><br><span class="line">System.out.println(file.length());          <span class="comment">// 433</span></span><br><span class="line">System.out.println(file.lastModified());    <span class="comment">// 1657240974716</span></span><br><span class="line">file = <span class="keyword">new</span> File(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(file.list()));      <span class="comment">// [MyAnno.java, test.java]</span></span><br><span class="line">System.out.println(Arrays.toString(file.listFiles())); <span class="comment">// [src\MyAnno.java, src\test.java]</span></span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;test.iml&quot;</span>);</span><br><span class="line">System.out.println(file.isDirectory()); <span class="comment">// false</span></span><br><span class="line">System.out.println(file.isFile());      <span class="comment">// true</span></span><br><span class="line">System.out.println(file.exists());      <span class="comment">// true</span></span><br><span class="line">System.out.println(file.canRead());     <span class="comment">// true</span></span><br><span class="line">System.out.println(file.canWrite());    <span class="comment">// true</span></span><br><span class="line">System.out.println(file.isHidden());    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="io流-1">IO流</h3>
<ul>
<li><p>四个抽象基类 | | 字节流 | 字符流 | | --- | --- | --- | | 输入流 | InputStream | Reader | | 输出流 | OutputStream | Writer |</p></li>
<li><p>IO流体系 | 分类 | 字节输入流 | 字节输出流 | 字符输入流 | 字符输出流 | | --- | --- | --- | --- | --- | | 抽象基类 | <strong>InputStream</strong> | <strong>OutputStream</strong> | <strong>Reader</strong> | <strong>Writer</strong> | | 访问文件 | <strong>FileInputStream</strong> | <strong>FileOutputStream</strong> | <strong>FileReader</strong> | <strong>FileWriter</strong> | | 访问数组 | ByteArrayInputStream | ByteArrayOutputStream | CharArrayReader | CharArrayWriter | | 访问管道 | PipedInputStream | PipedOutputStream | PipedReader | PipedWriter | | 访问字符串 | | | StringReader | StringWriter | | 缓冲流 | <strong>BufferedInputStream</strong> | <strong>BufferedOutputStream</strong> | <strong>BufferedReader</strong> | <strong>BufferedWriter</strong> | | 转换流 | | | <strong>InputStreamReader</strong> | <strong>OutputStreamWriter</strong> | | 对象流 | <strong>ObjectInputStream</strong> | <strong>ObjectOutputStream</strong> | | | | 打印流 | | PrintStream | | PrintWriter | | 推回输入流 | PushbackInputStream | | PushbackReader | | | 特殊流 | DataInputStream | DataOutputStream | | |</p></li>
</ul>
<h4 id="filereader">FileReader</h4>
<p>读入时，文件不存在会抛出异常</p>
<h5 id="实例化-5">实例化</h5>
<ol type="1">
<li>Reader reader = new FileReader(String fileName);</li>
<li>Reader reader = new FileReader(File file);</li>
</ol>
<h5 id="常用方法-8">常用方法</h5>
<ol type="1">
<li>read()：返回读入的一个字符(int型)，如果达到文件末尾，返回-1</li>
<li>read(char[] cbuf)：返回每次读入到cbuf数组中的字符的个数，如果达到文件末尾则返回-1</li>
<li>close()：关闭流 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>); <span class="comment">// 其它方法中是相对于当前Module, main方法中是相对于当前工程</span></span><br><span class="line">    reader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">    <span class="comment">// int data = reader.read();</span></span><br><span class="line">    <span class="comment">// while(data != -1)&#123;</span></span><br><span class="line">    <span class="comment">//    System.out.print((char)data);</span></span><br><span class="line">    <span class="comment">//    data = reader.read();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">// 简写 + 处理异常</span></span><br><span class="line">     <span class="keyword">int</span> data;</span><br><span class="line">     <span class="keyword">while</span> ((data = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">         System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="keyword">if</span>(reader!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             reader.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// HelloWorld!</span></span><br><span class="line"><span class="comment">// 第二行</span></span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=reader.read(cbuf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;len;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     System.out.print(cbuf[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">     String s = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">     System.out.print(s);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="filewriter">FileWriter</h4>
<p>写出时，文件不存在不会报错，会自动创建；如果存在则覆盖(或追加)</p>
<h5 id="实例化-6">实例化</h5>
<p>与FileReader类似</p>
<ol type="1">
<li>Writer writer = new FileWriter(File file);</li>
<li>Writer writer = new FileWriter(File file, boolean append);</li>
<li>Writer writer = new FileWriter(String fileName);</li>
<li>Writer writer = new FileWriter(String fileName, boolean append);</li>
</ol>
<h5 id="常用方法-9">常用方法</h5>
<ol type="1">
<li>write(char[] cbuf)：将字符数组写出</li>
<li>write(String str)：将字符串写出</li>
<li>close()：关闭流 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">&quot;new.txt&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;hello world\n&quot;</span>.toCharArray());</span><br><span class="line">writer.write(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="inputstream">InputStream</h4>
<p>与FileReader类似</p>
<h5 id="实例化-7">实例化</h5>
<ol type="1">
<li>InputStream is = new FileInputStream(File file);</li>
<li>InputStream is = new FileInputStream(String fileName);</li>
</ol>
<h5 id="常用方法-10">常用方法</h5>
<ol type="1">
<li>read()：返回读入的一个字节(int型)，如果达到文件末尾，返回-1</li>
<li>read(byte[] buf)：返回每次读入到buf数组中的字符的个数，如果达到文件末尾则返回-1</li>
<li>close()：关闭流 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;new.txt&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span>((len=is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    String  s = <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">    System.out.print(s); <span class="comment">// 如果有中文，就可能会存在乱码</span></span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="outputstream">OutputStream</h4>
<p>与FileWriter类似</p>
<h5 id="实例化-8">实例化</h5>
<p>与FileReader类似</p>
<ol type="1">
<li>OutputStream os = new FileOutputStream(File file);</li>
<li>OutputStream os= new FileOutputStream(File file, boolean append);</li>
<li>OutputStream os= new FileOutputStream(String fileName);</li>
<li>OutputStream os= new FileOutputStream(String fileName, boolean append);</li>
</ol>
<h5 id="常用方法-11">常用方法</h5>
<ol type="1">
<li>write(byte[] buf)：将字节数组写出</li>
<li>close()：关闭流</li>
</ol>
<h4 id="bufferedreaderbufferedwriter">BufferedReader/BufferedWriter</h4>
<p>与普通的FileReader、FileWriter类似，提高了读取和写出的速度，原因是内部提供了一个缓冲区 实例化：</p>
<ul>
<li>Reader reader = new BufferedReader(new FileReader("hello.txt"));</li>
<li>Writer writer = new BufferedWriter(new FileWriter("hello.txt"));</li>
</ul>
<p>使用与FileReader、FileWriter一样用 此外，多了<strong>flush()</strong>方法，用于刷新缓冲区(即立即将缓冲区数据读入/写出并清空)此外，还多了<strong>readLine()</strong>方法，用于读取一行 关闭时先关外层的流，再关内层的流；实际上关闭外层流时，会自动关闭内存流，所以内存流的关闭可省略</p>
<h4 id="bufferedinputstreambufferedinputstream">BufferedInputStream/BufferedInputStream</h4>
<p>与普通的FileInputStream、FileOutputStream类似，提高了读取和写出的速度 实例化：</p>
<ul>
<li>InputStream is = new BufferedInputStream(new FileInputStream("hello.txt"));</li>
<li>OutputStream os = new BufferedOutputStream(new FileOutputStream("hello.txt"));</li>
</ul>
<p>使用与FileInputStream、FileOutputStream一样 此外，多了<strong>flush()</strong>方法，用于刷新缓冲区； 关闭时先关外层的流，再关内层的流；实际上关闭外层流时，会自动关闭内存流，所以内存流的关闭可省略</p>
<h4 id="转换流inputstreamreaderoutputstreamwriter">转换流InputStreamReader、OutputStreamWriter</h4>
<p>InputStreamReader：将InputStream转换成Reader，实例化参数为InputStream，实例化后对象可以当作Reader用；</p>
<ul>
<li>InputStreamReader isr = new InputStreamReader(is, "UTF-8");</li>
<li>可指定字符编码集：ASCII、ISO8859-1、GB2312、GBK、Unicode、UTF-8</li>
</ul>
<p>OutputStreamWriter：将OutputStream转换成Writer；实例化参数为OutputStream，实例化后对象可以当作Writer用</p>
<ul>
<li>OutputStreamWriter osw = new OutputStreamWriter(os, "UTF-8");</li>
<li>可指定字符编码集 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="不常用流">不常用流</h4>
<h5 id="标准流">标准流</h5>
<ul>
<li>System.in和System.out分别代表了系统标准的输入和输出设备</li>
<li>System.in类型是InputStream，默认从控制台输入</li>
<li>System.out类型是PrintStream，是OutputStream的子类，默认从控制台输出</li>
<li>System类的setIn(InputStream in)/setOut(PrintStream out)方式重新指定输入和输出的流 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    String data = br.readLine();</span><br><span class="line">    <span class="keyword">if</span> (data.equalsIgnoreCase(<span class="string">&quot;e&quot;</span>) || data.equalsIgnoreCase(<span class="string">&quot;exit&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(data.toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="打印流">打印流</h5>
<ul>
<li>实现将基本数据类型的数据格式转换为字符串输出</li>
<li>PrintStream和PrintWriter</li>
<li>提供了一系列重载的print()和println()方法，用于多种类型数据的输出</li>
</ul>
<h5 id="数据流">数据流</h5>
<ul>
<li>DataInputStream和DataOutputStream</li>
<li>方便操作Java的基本数据类型和String类型的数据</li>
<li>实例化时传入参数为IO流</li>
<li>方法
<ul>
<li>readBoolean()</li>
<li>readByte()</li>
<li>readChar()</li>
<li>readFloat()</li>
<li>readDouble()</li>
<li>readShort()</li>
<li>readLong()</li>
<li>readInt()</li>
<li>readUTF()</li>
<li>readFully()</li>
<li>上述read换成write()即为DataOutputStream中的方法</li>
</ul></li>
</ul>
<h5 id="对象流">对象流</h5>
<ul>
<li>ObjectInputStream和ObjectOutputStream</li>
<li>用于存储和读取基本数据类型或对象的处理流。可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来</li>
<li>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</li>
<li>反序列化：用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</li>
<li>不能序列化<strong>static</strong>和<strong>transient</strong>修饰的成员变量</li>
</ul>
<p><strong>对象序列化</strong></p>
<ul>
<li><strong>对象序列化机制</strong>允许把内存中的Java对象转换成平台无关的二进制流，从而允许将这种二进制流持久保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流就可以恢复成原来的Java对象</li>
<li>序列化的好处在于可将任何实现了Serializable接口的对象转换成<strong>字节数据</strong>，使其在保存和传输时可被还原</li>
<li>序列化是RMI(Remote Method Invoke-远程方法调用)过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属类及其属于是可序列化的，为了某个类是可序列化的，该类必须实现如下两个接口之一，否则会抛出NotSerializableException异常
<ul>
<li><strong>Serializable</strong>
<ul>
<li><strong>内部定义：</strong>static final long serialVersionUID = ???L;</li>
<li>如果没有显示定义这个常量，则这个值是Java运行时环境根据类的内部细节自动生成。如类的实例变量做了修改，serialVersionUID可能发生变化 ，换句话说，可能会存在序列化后，修改类代码，然后无法反序列化回来的情况</li>
<li>内部所有属性也需要是可序列化的(默认情况下，基本数据类型都是可序列化的)</li>
</ul></li>
<li>Externalizable <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">3</span>);</span><br><span class="line">oos.writeObject(person);</span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">Person p = (Person) ois.readObject();</span><br><span class="line">System.out.println(p);</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h5 id="随机存取文件流">随机存取文件流</h5>
<ul>
<li>RandomAccessFile类</li>
<li>直接继承自java.lang.Object类，并实现了DataInput、DataOutput接口，表示这个类可读也可写</li>
<li>支持“随机访问”方式，程序可以直接跳到文件的任意地方来读、写文件
<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul></li>
<li>实例化：
<ul>
<li>RandomAccessFile raf = new RandomAccessFile(File file, String mode); // mode可选："r", "rw", "rws"可读可写，同步文件内容和元数据的更新, "rwd"：可读可写，同步文件内容更新</li>
<li>RandomAccessFile raf = new RandomAccessFile(String fileName, String mode);</li>
</ul></li>
<li>RandomAccessFile对象包含一个记录指针，以标示当前读写处的位置，可以自由移动记录指针
<ul>
<li>getFilePointer()：获取文件记录指针的当前位置</li>
<li>seek(long pos)：将文件记录指针定位到pos位置</li>
</ul></li>
<li>作为输出流时，写出到的文件不存在则执行过程中自动创建，如果写出到的文件已存在则会对原文件内容进行覆盖(默认从头覆盖) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;new.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">raf.seek(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=raf.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len)); <span class="comment">// loWorld!</span></span><br><span class="line">&#125;</span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="nio中的pathpathsfiles">NIO中的Path、Paths、Files</h5>
<p>NIO支持面向缓冲区(IO是面向流的)、基于通道的IO操作。NIO以更加高效的方式进行文件的读写操作</p>
<ul>
<li>java.nio.channels.Channel
<ul>
<li>FileChannel：处理本地文件</li>
<li>SocketChannel：TCP网络编程的客户端的Channel</li>
<li>ServerSocketChannel：TCP网络编程的服务端的Channel</li>
<li>DatagramChannel：UDP网络编程中发送端和接收端的Channel</li>
</ul></li>
<li>早期的Java只提供了一个File类来访问文件系统，但File类功能有限，所提供的方法性能也不高。而且，<strong>大多数方法在出错时仅返回失败，并不会提供异常信息</strong>。</li>
<li>NIO.2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<strong>Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</strong></li>
<li>以前IO操作：File file = new File("hello.txt");</li>
<li>NIO中：Path path = Paths.get("hello.txt");</li>
<li>NIO.2在java.nio.file包下提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法</li>
<li>Paths类提供的静态get()方法用来获取Path对象：
<ul>
<li>static Path get(String first, String...more)：用于将多个字符串串连成路径</li>
<li>static Path get(URI uri)：返回指定uri对应的Path路径</li>
</ul></li>
</ul>
<p>Path常用方法</p>
<table>
<thead>
<tr class="header">
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>toString()</td>
<td>返回调用Path对象的字符串表示</td>
</tr>
<tr class="even">
<td>startsWith(String path)</td>
<td>判断是否以path路径开始</td>
</tr>
<tr class="odd">
<td>endsWith(String path)</td>
<td>判断是否以path路径结束</td>
</tr>
<tr class="even">
<td>isAbsolute()</td>
<td>判断是否是绝对路径</td>
</tr>
<tr class="odd">
<td>Path getParent()</td>
<td>返回Path对象包含整个路径，不包含Path对象指定文件路径</td>
</tr>
<tr class="even">
<td>Path getRoot()</td>
<td>返回调用Path对象的根路径</td>
</tr>
<tr class="odd">
<td>Path getFileName()</td>
<td>返回与调用Path对象关联的文件名</td>
</tr>
<tr class="even">
<td>getNameCount()</td>
<td>返回Path根目录后面元素的数量</td>
</tr>
<tr class="odd">
<td>Path getName(int idx)</td>
<td>返回指定索引idx的路径名称</td>
</tr>
<tr class="even">
<td>Path toAbsolute()</td>
<td>作为绝对路径返回调用Path对象</td>
</tr>
<tr class="odd">
<td>Path resolve(Path p)</td>
<td>合并两个路径，返回合并后的路径对应的Path对象</td>
</tr>
<tr class="even">
<td>File toFile()</td>
<td>将Path转换成File类对象</td>
</tr>
</tbody>
</table>
<p>Files类常用方法</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Path copy(Path src, Path dest, CopyOption... how)</td>
<td>文件复制</td>
</tr>
<tr class="even">
<td>Path createDirectory(Path path, FileAttribute&lt;?&gt;... attr)</td>
<td>创建一个目录</td>
</tr>
<tr class="odd">
<td>Path createFile(Path path, FileAttribute&lt;?&gt;... attr)</td>
<td>创建一个文件</td>
</tr>
<tr class="even">
<td>void delete(Path path)</td>
<td>删除一个文件或目录，如果不存在，则报错</td>
</tr>
<tr class="odd">
<td>deleteIfExists(Path path)</td>
<td>如果Path对应文件或目录如果存在则删除</td>
</tr>
<tr class="even">
<td>Path move(Path src, Path desc, CopyOption... how)</td>
<td>文件移动</td>
</tr>
<tr class="odd">
<td>long size(Path path)</td>
<td>返回path指定文件的大小</td>
</tr>
<tr class="even">
<td>exists(Path path, LinkOption... opts)</td>
<td>判断文件是否存在</td>
</tr>
<tr class="odd">
<td>isDirectory(Path path, LinkOption... opts)</td>
<td>判断是否是目录</td>
</tr>
<tr class="even">
<td>isRegularFile(Path path, LinkOption... opts)</td>
<td>判断是否是文件</td>
</tr>
<tr class="odd">
<td>isHidden(Path path)</td>
<td>判断是否是隐藏文件</td>
</tr>
<tr class="even">
<td>isReadable(Path path)</td>
<td>判断是否可读</td>
</tr>
<tr class="odd">
<td>isWriteable(Path path)</td>
<td>判断是否可写</td>
</tr>
<tr class="even">
<td>notExists(Path path, LinkOption... opts)</td>
<td>判断文件是否不存在</td>
</tr>
<tr class="odd">
<td>SeekableByteChannel new ByteChannel(Path path, OpenOption... how)</td>
<td>获取与指定文件的连接，how指定打开方式</td>
</tr>
<tr class="even">
<td>DirectoryStream<Path> newDirectoryStream(Path path)</td>
<td>打开path指定的目录</td>
</tr>
<tr class="odd">
<td>InputStream newInputStream(Path path, OpenOption... how)</td>
<td>获取InputStream对象</td>
</tr>
<tr class="even">
<td>OutputStream newOutputStream(Path path, OpenOption... how)</td>
<td>获取OutputStream对象</td>
</tr>
</tbody>
</table>
<h2 id="网络编程">网络编程</h2>
<h3 id="ip地址inetaddress">IP地址InetAddress</h3>
<h4 id="实例化-9">实例化</h4>
<ol type="1">
<li>InetAddress.getByName(String host);// host可以是IP地址也可以是域名</li>
<li>InetAddress.getLocalHost(); 本地主机 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InetAddress ip = InetAddress.getByName(<span class="string">&quot;192.168.1.1&quot;</span>);</span><br><span class="line">System.out.println(ip); <span class="comment">// /192.168.1.1</span></span><br><span class="line">InetAddress ip2 = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">System.out.println(ip2); <span class="comment">// www.baidu.com/180.101.49.12</span></span><br><span class="line">InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(localHost); <span class="comment">// LAPTOP-ABCDEFG/192.168.1.3</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="常用方法-12">常用方法</h4>
<ol type="1">
<li>getHostName()：获取主机名(域名或IP地址)</li>
<li>getHostAddress()：获取主机地址</li>
</ol>
<h3 id="socket">Socket</h3>
<h4 id="实例化-10">实例化</h4>
<ol type="1">
<li>Socket socket = new Socket(InetAddress ip, int port);</li>
<li>Socket socket = new Socket(String host, int port);</li>
</ol>
<h4 id="常用方法-13">常用方法</h4>
<ol type="1">
<li>socket.getOutputStream(); 获取OutputStream流</li>
<li>close()：关闭socket <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InetAddress ip = InetAddress.getLocalHost();</span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(ip, <span class="number">8888</span>);</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br><span class="line">os.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">os.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="serversocket">ServerSocket</h3>
<h4 id="实例化-11">实例化</h4>
<ol type="1">
<li>ServerSocket serverSocket = new ServerSocket(int port);</li>
</ol>
<h4 id="常用方法-14">常用方法</h4>
<ol type="1">
<li>Socket accept()：阻塞serverSocket，返回从客户端接收的Socket <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line"><span class="comment">// 直接写中文可能存在乱码，最好转换一下</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="datagramsocket">DatagramSocket</h3>
<h4 id="实例化-12">实例化</h4>
<ol type="1">
<li>DatagramSocket socket = new DatagramSocket();</li>
<li>DatagramSocket socket = new DatagramSocket(int port);</li>
<li>DatagramSocket socket = new DatagramSocket(int port, InetAddress Iaddr);</li>
</ol>
<h4 id="常用方法-15">常用方法</h4>
<ol type="1">
<li>send(DatagramPacket packet)：发送数据报
<ol type="1">
<li>DatagramPacket packet = new DatagramPacket(byte[] buf, int length, InetAddress address, int port); // 实例化DatagramPacket</li>
<li>DatagramPacket packet = new DatagramPacket(byte[] buf, int length);</li>
<li>packet.getData()：获取数据报中的内容(字节数组)</li>
<li>packet.getLength()：获取数据报中内容长度</li>
</ol></li>
<li>close()：关闭socket <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送端</span></span><br><span class="line">DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(s.getBytes(), s.length(), InetAddress.getLocalHost(), <span class="number">8888</span>)</span><br><span class="line">socket.send(packet);</span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收端</span></span><br><span class="line">DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, <span class="number">0</span>, buf.length);</span><br><span class="line">socket.receive(packet);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,  packet.getLength()));</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="url编程">URL编程</h3>
<ul>
<li>URL类</li>
</ul>
<p>实例化：</p>
<ol type="1">
<li>URL url = new URL(String spec);通过URL地址构造对象</li>
<li>URL url = new URL(URL context, String spec);通过一个基URL和相对地址构造对象</li>
<li>URL url = new URL(String protocol, String host, String file);</li>
<li>URL url = new URL(String protocol, String host, int port, String file);</li>
</ol>
<p>常用方法：</p>
<ol type="1">
<li><p>getProtocol()：获取协议名</p></li>
<li><p>getHost()：获取主机名</p></li>
<li><p>getPort()：获取端口号</p></li>
<li><p>getPath()：获取文件路径</p></li>
<li><p>getFile()：获取文件名</p></li>
<li><p>getQuery()：获取查询 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://127.0.0.1/index.html?username=abc&quot;</span>);</span><br><span class="line">System.out.println(url.getProtocol()); <span class="comment">// http</span></span><br><span class="line">System.out.println(url.getHost());     <span class="comment">// 127.0.0.1</span></span><br><span class="line">System.out.println(url.getPath());     <span class="comment">// /index.html</span></span><br><span class="line">System.out.println(url.getFile());     <span class="comment">// /index.html?username=abc</span></span><br><span class="line">System.out.println(url.getQuery());    <span class="comment">// username=abc</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>openConnection()：开启一个URL连接，开启的连接可以通过connect真正连接上 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://cn.bing.com/th?id=OHR.DolbadarnCastle_ZH-CN5397592090_1920x1080.jpg&quot;</span>);</span><br><span class="line">HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">urlConnection.connect();</span><br><span class="line">InputStream is = urlConnection.getInputStream();</span><br><span class="line">System.out.println(url.getFile());</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;t.jpg&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br><span class="line">fos.close();</span><br><span class="line">urlConnection.disconnect();</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="反射">反射</h2>
<ul>
<li>反射(Reflection)是动态语言的关键，反射允许程序在执行期通过对应API获取任何类的内部信息，并能直接操作任意对象的内部属性和方法</li>
<li>加载完类之后，在堆内存的方法区就会产生一个Class类型对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息，可以通过这个对象看到类的结构。这个对象就像一面镜子，能通过它看到类的结构，所以称为“反射”
<ul>
<li>正常方式：引入需要的"包类"名称-&gt;通过new实例化-&gt;取得实例化对象</li>
<li>反射方式：实例化对象-&gt;getClass()方法-&gt;得到完整的"包类"名称</li>
</ul></li>
<li>反射相关的主要API
<ul>
<li><strong>java.lang.Class</strong>：代表一个类</li>
<li>java.lang.reflect.Method：代表类的方法</li>
<li>java.lang.reflect.Field：代表类的成员变量</li>
<li>java.lang.reflect.Constructor：代表类的构造器</li>
<li>..... <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">p.publicMethod();</span><br><span class="line"><span class="comment">// 反射的形式做相同的事</span></span><br><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">Constructor&lt;Person&gt; constructor = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">Person person = constructor.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(person); <span class="comment">// Person&#123;name=&#x27;Tom&#x27;, age=20&#125;</span></span><br><span class="line">Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">name.set(person, <span class="string">&quot;Jerry&quot;</span>); <span class="comment">// Person&#123;name=&#x27;Jerry&#x27;, age=20&#125;</span></span><br><span class="line">System.out.println(person);</span><br><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">&quot;publicMethod&quot;</span>);</span><br><span class="line">method.invoke(person); <span class="comment">// 公有方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还通过反射能调用私有成员</span></span><br><span class="line">Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">age.setAccessible(<span class="keyword">true</span>); <span class="comment">// 设置可访问</span></span><br><span class="line">age.set(person, <span class="number">12</span>);</span><br><span class="line">System.out.println(person); <span class="comment">// Person&#123;name=&#x27;Jerry&#x27;, age=12&#125;</span></span><br><span class="line">Method privateMethod = clazz.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateMethod.invoke(person); <span class="comment">// 私有方法</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>反射与封装：
<ul>
<li>封装性是一种建议型的，建议调用public不调用private，为了更好的代码安全性</li>
<li>反射是一种功能型的，提供这种技术，在需要时可以使用，保证了Java的动态性特征</li>
</ul></li>
<li>java.lang.Class类的理解：
<ul>
<li>在程序运行时会加载类，而被加载到内存中的类称为运行时类，这样的运行时类就是Class的一个实例</li>
<li>换句话说，Class的一个实例就对应着一个运行时类</li>
</ul></li>
</ul>
<h3 id="获取class实例的4种方式">获取Class实例的4种方式</h3>
<ol type="1">
<li><p>调用运行时类的属于：Person.class</p></li>
<li><p>通过运行时类对象调用getClass()：new Person().getClass()</p></li>
<li><p><strong>调用Class的静态方法：Person.forName(String classPath);(使用较多)</strong></p></li>
<li><p>通过类加载器加载 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz2 = p.getClass();</span><br><span class="line">Class clazz3 = Class.forName(<span class="string">&quot;com.zephon.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz1==clazz2); <span class="comment">// true</span></span><br><span class="line">System.out.println(clazz1==clazz3); <span class="comment">// true</span></span><br><span class="line">ClassLoader classLoader = TestReflection.class.getClassLoader();</span><br><span class="line">Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.zephon.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz1==clazz4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure> :::success 哪些类型可以有Class对象？</p></li>
<li><p>class：外部类、成员(成员内部类、静态内部类)、局部内部类、匿名内部类</p></li>
<li><p>interface：接口</p></li>
<li><p>[]：数组</p></li>
<li><p>enum：枚举</p></li>
<li><p>annotation：注解@interface</p></li>
<li><p>primitive type：基本数据类型</p></li>
<li><p>void :::</p></li>
</ol>
<h3 id="使用classloader加载配置文件">使用ClassLoader加载配置文件</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">//        FileInputStream fis = new FileInputStream(&quot;src\\test.properties&quot;); // 默认识别为当前Module下</span></span><br><span class="line"><span class="comment">//        properties.load(fis);</span></span><br><span class="line"><span class="comment">//        fis.close();</span></span><br><span class="line">        ClassLoader classLoader = test.class.getClassLoader();</span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;test.properties&quot;</span>); <span class="comment">// 此时识别位置是src下</span></span><br><span class="line">        properties.load(is);</span><br><span class="line">        System.out.println(properties); <span class="comment">// &#123;password=123, name=名称&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="反射作用">反射作用</h3>
<h4 id="创建运行时类的对象">创建运行时类的对象</h4>
<ol type="1">
<li>newInstance()：创建对应的运行时类的对象(调用的空参构造器，没有空参构造器或没有权限则抛出异常)，所以通常在Java Bean中需要提供一个空参构造器(也方便父类默认调用super()使用)</li>
</ol>
<h4 id="获取运行时类的属性开发中使用不多">获取运行时类的属性(开发中使用不多)</h4>
<ol type="1">
<li>Fields[] getFields()：获取当前运行时类及其父类所有public属性</li>
<li>Fields[] getDeclaredFields()：获取当前运行时类所有属性(包括private，不包含父类属性)</li>
<li>Field getField(String name)：获取指定名的属性</li>
</ol>
<ul>
<li>Field：
<ul>
<li>int getModifiers()：获取权限修饰符，返回整型，可用Modifier.toString(int m)转换回字符串</li>
<li>Class getType()：获取数据类型</li>
<li>String getName()：获取变量名</li>
</ul></li>
</ul>
<ol start="4" type="1">
<li>Field getDeclaredField(String name) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field); <span class="comment">// public java.lang.String com.zephon.java.Person.name</span></span><br><span class="line">&#125;</span><br><span class="line">Field[] fields1 = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields1) &#123;</span><br><span class="line">    System.out.println(field);</span><br><span class="line">    <span class="comment">// public java.lang.String com.zephon.java.Person.name</span></span><br><span class="line">    <span class="comment">// private int com.zephon.java.Person.age</span></span><br><span class="line">&#125;</span><br><span class="line">Field f = clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> modifiers = f.getModifiers();</span><br><span class="line">System.out.println(Modifier.toString(modifiers)); <span class="comment">// public</span></span><br><span class="line">Class type = f.getType();</span><br><span class="line">System.out.println(type); <span class="comment">// class java.lang.String</span></span><br><span class="line">System.out.println(f.getName()); <span class="comment">// name</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="获取运行时类的方法">获取运行时类的方法</h4>
<ol type="1">
<li>Method[] getMethods()：获取当前运行时类及其父类所有public方法</li>
<li>Method[] getDeclaredMethods()：获取当前运行时类所有方法(包括private，不包含父类方法)</li>
<li>Method getMethod(String name)：获取指定名的方法</li>
</ol>
<ul>
<li>Method:
<ul>
<li>Annotation[] getAnnotations()：获取所有注解</li>
<li>int getModifiers()：获取权限修饰符</li>
<li>Class getReturnType()：获取返回值类型</li>
<li>getName()：获取方法名</li>
<li>Class[] getParameterTypes()：获取所有参数的类型</li>
<li>Class[] getExceptionTypes()：获取所有异常类型</li>
</ul></li>
</ul>
<ol start="4" type="1">
<li>Method getDeclaredMethod(String name) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">Method[] methods1 = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods1) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">Method m = clazz.getMethod(<span class="string">&quot;publicMethod&quot;</span>);</span><br><span class="line">Annotation[] annotations = m.getAnnotations();</span><br><span class="line">System.out.println(Arrays.toString(annotations)); <span class="comment">// [@java.lang.Deprecated()]</span></span><br><span class="line"><span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">System.out.println(Modifier.toString(modifiers)); <span class="comment">// public</span></span><br><span class="line">Class&lt;?&gt; returnType = m.getReturnType();</span><br><span class="line">System.out.println(returnType); <span class="comment">// void</span></span><br><span class="line">System.out.println(m.getName()); <span class="comment">// publicMethod</span></span><br><span class="line">Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span><br><span class="line">System.out.println(Arrays.toString(parameterTypes)); <span class="comment">// []</span></span><br><span class="line">Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line">System.out.println(Arrays.toString(exceptionTypes)); <span class="comment">// [class java.lang.Exception]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="获取运行时构造器">获取运行时构造器</h4>
<ol type="1">
<li>Constructor&lt;?&gt;[] getConstructors();获取当前运行时类中声明为public的构造器</li>
<li>Constructor&lt;?&gt;[] getDeclaredConstructors();获取当前运行时类中所有构造器</li>
<li>Constructor&lt;?&gt; getConstructor(Class ...a);获取指定参数类型的构造器</li>
<li>Constructor&lt;?&gt; clazz.getDeclaredConstructor(); <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">    System.out.println(constructor);</span><br><span class="line">    <span class="comment">// public com.zephon.java.Person()</span></span><br><span class="line">    <span class="comment">// public com.zephon.java.Person(java.lang.String,int)</span></span><br><span class="line">&#125;</span><br><span class="line">Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">    System.out.println(declaredConstructor);</span><br><span class="line">    <span class="comment">// private com.zephon.java.Person(int)</span></span><br><span class="line">    <span class="comment">// public com.zephon.java.Person(java.lang.String,int)</span></span><br><span class="line">    <span class="comment">// public com.zephon.java.Person()</span></span><br><span class="line">&#125;</span><br><span class="line">Constructor&lt;Person&gt; constructor = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(constructor);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="获取运行时类的父类及父类的泛型">获取运行时类的父类及父类的泛型</h4>
<ol type="1">
<li>Class getSuperclass();获取运行时类的父类</li>
<li>Type getGenericSuperclass();获取运行时类的带泛型的父类</li>
<li><strong>(ParameterizedType) genericSuperclass; ParameterizedType中的getActualTypeArguments()获取运行时类的带泛型的父类的泛型</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">Class&lt;? <span class="keyword">super</span> Person&gt; superclass = clazz.getSuperclass();</span><br><span class="line">System.out.println(superclass); <span class="comment">// com.zephon.java.Creature</span></span><br><span class="line">Type genericSuperclass = clazz.getGenericSuperclass();</span><br><span class="line">System.out.println(genericSuperclass); <span class="comment">// com.zephon.java.Creature&lt;java.lang.String&gt;</span></span><br><span class="line">ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;</span><br><span class="line">Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line">System.out.println((Class)types[<span class="number">0</span>].getName());</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="获取运行时类的接口所在包注解等">获取运行时类的接口、所在包、注解等</h4>
<ol type="1">
<li><strong>Class[] getInterfaces();获取运行时类的接口</strong></li>
<li>Package getPackage();获取运行时类的包</li>
<li>Annotation[] getAnnotations();获取运行时类的注解 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">    System.out.println(anInterface); <span class="comment">// interface java.io.Serializable</span></span><br><span class="line">&#125;</span><br><span class="line">Package aPackage = clazz.getPackage();</span><br><span class="line">System.out.println(aPackage); <span class="comment">// package com.zephon.java</span></span><br><span class="line">Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    System.out.println(annotation); <span class="comment">// @com.zephon.java.MyAnno(value=test)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="调用运行时类中的指定属性方法构造器">调用运行时类中的指定属性、方法、构造器</h4>
<ol type="1">
<li>Field field = clazz.getDeclaredField(String name)：获取指定属性</li>
</ol>
<ul>
<li>如需要操作的是非public属性，则需要设置权限field.setAccessible(true);</li>
<li>Field：
<ul>
<li>field.setAccessible(true);设置权限可访问</li>
<li>field.set(Object obj, Object value);obj：指明设置哪个对象的属性 value：将此属性设置为多少</li>
<li>field.get(Object obj); obj：获取哪个对象的当前属性值</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>Method method = clazz.getDeclaredMethod(String name);获取指定方法</li>
</ol>
<ul>
<li>如需要操作的是非public方法，则需要设置权限field.setAccessible(true);</li>
<li>Method:
<ul>
<li>method.setAccessible(true);设置权限可访问</li>
<li>Object result = method.invoke(Object obj, Object ...args);方法调用，obj：方法的调用者；...args：方法的参数；result：方法返回值；如果obj是null或clazz则是调用静态方法</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li>Constructor&lt;&gt; constructor = clazz.getDeclaredConstructor(Class c);获取指定构造器，c：指明构造器参数列表类型</li>
</ol>
<ul>
<li>Constructor：
<ul>
<li>constructor .setAccessible(true);设置权限可访问</li>
<li>Object obj = constructor.newInstance(Object ...args);args：构造器参数；obj：返回的实例化对象</li>
</ul></li>
</ul>
<h3 id="反射的应用动态代理">反射的应用：动态代理</h3>
<ul>
<li><p>动态代理使用场景：</p>
<ul>
<li>调试</li>
<li>远程方法调用</li>
</ul></li>
<li><p>相比静态代理优点：</p>
<ul>
<li>抽象角色中声明的所有方法都被转移到调用处理器的一个集中方法中处理，可以更加灵活和统一的处理众多方法</li>
</ul></li>
<li><p>静态代理：代理类和被代理类在编译期间就已经确定 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理类额外操作&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.factory.produceCloth();</span><br><span class="line">        System.out.println(<span class="string">&quot;代理类做后续工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被代理类的工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// 创建被代理类对象</span></span><br><span class="line">NikeClothFactory nikeClothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line"><span class="comment">// 创建代理类对象</span></span><br><span class="line">ProxyClothFactory proxyClothFactory = <span class="keyword">new</span> ProxyClothFactory(nikeClothFactory);</span><br><span class="line">proxyClothFactory.produceCloth();</span><br></pre></td></tr></table></figure></p></li>
<li><p>动态代理： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被代理类的工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个代理类对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 被代理类对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;代理类额外操作&quot;</span>);</span><br><span class="line">                Object res = method.invoke(obj, args); <span class="comment">// 注：这里是obj，表示调用被代理类对象的方法</span></span><br><span class="line">                System.out.println(<span class="string">&quot;代理类做后续工作&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">NikeClothFactory nikeClothFactory = <span class="keyword">new</span> NikeClothFactory();</span><br><span class="line">ClothFactory proxyInstance = (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line">proxyInstance.produceCloth();</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="java-8新特性">Java 8新特性</h2>
<h3 id="lambda表达式">Lambda表达式</h3>
<p>本质：作为函数式接口的实例 格式：</p>
<ul>
<li>"-&gt;"：lambda操作符 或 箭头操作符</li>
<li>"-&gt;"左边：lambda形参列表(其实就是接口中抽象方法的形参列表)</li>
<li>"-&gt;"右边：lambda体(其实就是重写的抽象方法的方法体)</li>
</ul>
<p>使用：</p>
<ol type="1">
<li><p>无参无返回值 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123;System.out.println(<span class="string">&quot;Hello&quot;</span>);&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>一个参数，无返回值 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (String s)-&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>一个参数，无返回值，数据类型可以省略 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (s)-&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>若只有一个参数，则参数小括号可省略 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = s-&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>若两个或两个以上参数，多条执行语句，并且有返回值 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;实现函数式接口&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> x.compareTo(y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果只有一条执行语句，return和大括号可省略 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = s-&gt; System.out.println(s);</span><br><span class="line">Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="函数式functional接口">函数式(Functional)接口</h3>
<p>如果一个接口中只声明了一个抽象方法，则此接口就称为函数式接口：<span class="citation" data-cites="FunctionalInterface">@FunctionalInterface</span> 自定义函数式接口： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="java内置的四大核心函数式接口">Java内置的四大核心函数式接口：</h4>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Consumer<T> 消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型T的对象应用操作，包含方法: void accept(T t);</td>
</tr>
<tr class="even">
<td>Supplier<T> 供给型接口</td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象，包含方法：T get();</td>
</tr>
<tr class="odd">
<td>Function&lt;T, R&gt; 函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型为T的对象应用操作，并返回结果，结果是R类型的对象。包含方法：R apply(T t);</td>
</tr>
<tr class="even">
<td>Predicate<T> 断定型接口</td>
<td>T</td>
<td>boolean</td>
<td>确定类型为T的对象是否满足约束，并返回boolean值。包含方法：boolean test(T t);</td>
</tr>
</tbody>
</table>
<p>案例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>, <span class="string">&quot;weq&quot;</span>);</span><br><span class="line">    List&lt;String&gt; res = filterString(list, s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.test(s)) res.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="其它内置接口">其它内置接口</h4>
<table>
<thead>
<tr class="header">
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BiFunction&lt;T,U,R&gt;</td>
<td>T,U</td>
<td>R</td>
<td>对类型为T,U参数应用操作，返回R类型结果，包含方法：R apply(T t, U u);</td>
</tr>
<tr class="even">
<td>UnaryOperator<T></td>
<td>T</td>
<td>T</td>
<td>对类型为T的对象进行一元运算，并返回T类型结果，包含方法：T apply(T t);</td>
</tr>
<tr class="odd">
<td>BinaryOperator<T></td>
<td>T,T</td>
<td>T</td>
<td>对类型为T的对象进行二元运算，并返回T类型的结果，包含方法：T apply(T t1, T t2);</td>
</tr>
<tr class="even">
<td>BiConsumer&lt;T, U&gt;</td>
<td>T,U</td>
<td>void</td>
<td>对类型为T,U参数应用操作。包含方法为：void accept(T t, U u);</td>
</tr>
<tr class="odd">
<td>BiPredicate&lt;T, U&gt;</td>
<td>T,U</td>
<td>boolean</td>
<td>包含方法为：boolean test(T t,U u);</td>
</tr>
<tr class="even">
<td>ToIntFunction<T></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>ToLongFunction<T> ToDoubleFunction<T> | T | int long double | 分别计算int、long、double值的函数 | | IntFunction<R> LongFunction<R> DoubleFunction<R> | int long double | R | 参数分别为int、long、double类型的函数 |</p>
<h3 id="方法引用与构造器引用">方法引用与构造器引用</h3>
<ul>
<li>当要传递给Lambda体的操作已经有实现的方法了，可以使用方法引用</li>
<li>方法引用可以看作是Lambda表达式的深层次表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖</li>
<li>要求：<strong>实现接口的抽象方法的参数列表和返回值类型必须与方法引用的方法的参数列表和返回值类型保持一致</strong></li>
<li>格式：使用操作符"<strong>::</strong>"将类(对象)与方法名分隔开来</li>
<li>三种主要使用情况：
<ul>
<li><strong>对象::实例方法名</strong></li>
<li><strong>类::静态方法名</strong></li>
<li><strong>类::实例方法名</strong></li>
</ul></li>
</ul>
<p>例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c = System.out::println;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Consumer&lt;String&gt; c = s -&gt; System.out.println(s);</span><br><span class="line">c.accept(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comp = Integer::compare;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Comparator&lt;Integer&gt; comp = (t1, t2)-&gt;Integer.compare(t1, t2);</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comp = Integer::compareTo;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Comparator&lt;Integer&gt; comp = (t1, t2)-&gt;t1.compareTo(t2);</span><br></pre></td></tr></table></figure> 构造器引用： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; sup = Person::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Supplier&lt;Person&gt; sup = () -&gt; <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure> 带参构造器： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Person&gt; func = Person::<span class="keyword">new</span>;</span><br><span class="line">func.apply(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Function&lt;Integer, Person&gt; func = age -&gt; <span class="keyword">new</span> Person(age);</span><br><span class="line">func.apply(<span class="number">20</span>);</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;String, Integer, Person&gt; func = Person::<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">BiFunction&lt;String, Integer, Person&gt; func = (name, age) -&gt; <span class="keyword">new</span> Person(name, age);</span><br></pre></td></tr></table></figure> 数组引用： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, String[]&gt; func = length-&gt; <span class="keyword">new</span> String[length];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">Function&lt;Integer, String[]&gt; func = String[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="stream-api">Stream API</h3>
<ul>
<li>Stream是Java8中处理集合的关键抽象概念，可以指定对集合进行操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API对集合数据进行操作，就类似于使用SQL执行的数据库查询。</li>
<li>Stream 和Collection集合的区别：Collection是一种静态的内存数据结构，而Stream是有关计算的。前者主要面向内存，存储在内存中，后者主要面向CPU，通过CPU实现计算</li>
<li>Stream操作是延迟执行的，会等到需要结果时才执行</li>
<li>Stream 操作的三个步骤
<ol type="1">
<li>创建Stream：一个数据源(如：集合、数组)，获取一个流</li>
<li>中间操作：一个中间操作链，对数据源进行处理</li>
<li>终止操作：一旦执行终止操作，就<strong>执行中间操作链</strong>，并产生结果。之后不会再被使用</li>
</ol></li>
</ul>
<h4 id="创建的stream">创建的Stream</h4>
<ol type="1">
<li>通过集合
<ol type="1">
<li>Stream<E> stream()：返回一个顺序流</li>
<li>Stream<E> parallelStream()：返回一个并行流</li>
</ol></li>
<li>通过数组(Arrays的静态方法)
<ol type="1">
<li>Arrays.stream(T[] array);返回一个流</li>
</ol></li>
<li>通过Stream类的静态方法of()
<ol type="1">
<li>Stream.of(T... values)：返回一个流</li>
</ol></li>
<li>创建无限流(使用较少)
<ol type="1">
<li>Stream.iterate(final T seed, final UnaryOperator<T> f)：迭代
<ol type="1">
<li>例：Stream.iterate(0, t-&gt;t+2); // 遍历前n个偶数</li>
</ol></li>
<li>Stream.generate(Supplier<T> s)：生成</li>
</ol></li>
</ol>
<h4 id="stream的中间操作">Stream的中间操作</h4>
<h5 id="筛选与切片">1、筛选与切片</h5>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>filter(Predicate p)</td>
<td>接收Lambda，从流中排除某些元素</td>
</tr>
<tr class="even">
<td>distinct()</td>
<td>筛选，通过流所生成的元素的hashCode()和equals()去除重复元素</td>
</tr>
<tr class="odd">
<td>limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr class="even">
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补</td>
</tr>
</tbody>
</table>
<h5 id="映射">2、映射</h5>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>map(Function f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td>
</tr>
<tr class="even">
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的DoubleStream</td>
</tr>
<tr class="odd">
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的IntStream</td>
</tr>
<tr class="even">
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的LongStream</td>
</tr>
<tr class="odd">
<td>flatMap(Function f)</td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流(会以类似解包的方式将嵌套的流解开)</td>
</tr>
</tbody>
</table>
<h5 id="排序">3、排序</h5>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr class="even">
<td>sorted(Compartor com)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody>
</table>
<h4 id="stream的终止操作">Stream的终止操作</h4>
<h5 id="匹配与查找">1、匹配与查找</h5>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr class="even">
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr class="odd">
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr class="even">
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr class="odd">
<td>findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
<tr class="even">
<td>count()</td>
<td>返回流中元素总个数</td>
</tr>
<tr class="odd">
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr class="even">
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr class="odd">
<td>forEach(Consumer c)</td>
<td>内部迭代(使用Collection接口需要用户去做迭代称为外部迭代)</td>
</tr>
</tbody>
</table>
<h5 id="归约">2、归约</h5>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>reduce(T iden, BinaryOperator b)</td>
<td>可以将流中元素反复结合起来得到一个值。返回T</td>
</tr>
<tr class="even">
<td>reduce(BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一个值，返回Optinal<T></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">list.stream().reduce((x1, x2)-&gt;x1+x2);</span><br></pre></td></tr></table></figure>
<h5 id="收集">3、收集</h5>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>collect(Collector c)</td>
<td>将流转换为其它形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法</td>
</tr>
</tbody>
</table>
<p>此外Collectors实例类提供了很多静态方法，可以方便地创建常见收集器实例</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>返回类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>toList</td>
<td>List<T></td>
<td>将流中元素收集到List</td>
</tr>
<tr class="even">
<td>toSet</td>
<td>Set<T></td>
<td>将流中元素收集到Set</td>
</tr>
<tr class="odd">
<td>toCollection</td>
<td>Collection<T></td>
<td>将流中元素收集到创建的集合</td>
</tr>
<tr class="even">
<td>counting</td>
<td>Long</td>
<td>计算流中元素的个数</td>
</tr>
<tr class="odd">
<td>summingInt</td>
<td>Integer</td>
<td>对流中元素的整数属性求和</td>
</tr>
<tr class="even">
<td>averagingInt</td>
<td>Double</td>
<td>计算流中元素Integer属性的平均值</td>
</tr>
<tr class="odd">
<td>summarizingInt</td>
<td>IntSummaryStatistics</td>
<td>收集流中Integer属性的统计值。如：平均值</td>
</tr>
<tr class="even">
<td>joining</td>
<td>String</td>
<td>连接流中每个字符串</td>
</tr>
<tr class="odd">
<td>maxBy</td>
<td>Optional<T></td>
<td>根据比较器选择最大值</td>
</tr>
<tr class="even">
<td>minBy</td>
<td>Optional<T></td>
<td>根据比较器选择最小值</td>
</tr>
<tr class="odd">
<td>reducing</td>
<td>归约产生的类型</td>
<td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
</tr>
<tr class="even">
<td>collectiongAndThen</td>
<td>转换函数返回的类型</td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
<tr class="odd">
<td>groupingBy</td>
<td>Map&lt;K, List<T>&gt;</td>
<td>根据某个属性值对流分组，属性为K，结果为V</td>
</tr>
<tr class="even">
<td>partitioningBy</td>
<td>Map&lt;Boolean,List<T>&gt;</td>
<td>根据true/false进行分区</td>
</tr>
</tbody>
</table>
<h3 id="optional">Optional</h3>
<ul>
<li>空指针异常是导致java应用程序失败的最常见原因</li>
<li>Optinal<T>类(java.util.Optional)是一个容器类，可以保存类型T的值，代表这个值存在。或仅仅保存null，表示这个值不存在。原来用null表示一个值不存在，现在Optional可以更好的表达这个概念。并且可以避免空指针异常。</li>
</ul>
<p>创建Optional类对象的方法：</p>
<ul>
<li>Optional.of(T t)：创建一个Optional实例，t必须非空</li>
<li>Optional.empty()：创建一个空的Optional实例</li>
<li>Optional.ofNumber(T t)：t可以为null</li>
</ul>
<p>判断Optional容器中是否包含对象：</p>
<ul>
<li>boolean isPresent()：判断是否包含对象</li>
<li>void isPresent(Consumer&lt;? super T&gt; consumer)：如果有值，就执行consumer接口的实现代码，并且该值会作为参数传给它</li>
</ul>
<p>获取Optional容器的对象：</p>
<ul>
<li>T get()：如果调用对象包含值，则返回，否则抛出异常</li>
<li>T orElse(T other)：如果有值则返回，否则返回指定的other</li>
<li>T orElseGet(Supplier&lt;? extends T&gt; other)：如果有值则返回，否则返回Supplier接口实现提供的对象</li>
<li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)：如果有值则返回，否则抛出由Supplier接口实现提供的异常</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Zephon
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.zephon.eu.org/blog/2022/07/27/Java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/" title="Java基础查漏补缺">http://www.zephon.eu.org/blog/2022/07/27/Java基础查漏补缺/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/blog/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/06/09/MCUNetV2Memory-Efficient-Patch-based-Inference-for-Tiny-Deep-Learning/" rel="prev" title="《MCUNetV2:Memory-Efficient Patch-based Inference for Tiny Deep Learning》">
      <i class="fa fa-chevron-left"></i> 《MCUNetV2:Memory-Efficient Patch-based Inference for Tiny Deep Learning》
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/07/28/JDBC/" rel="next" title="JDBC">
      JDBC <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80MDY3OS8xNzIwNA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%9F%BA%E7%A1%80%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA"><span class="nav-number">1.</span> <span class="nav-text">Java基础查漏补缺</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3"><span class="nav-number">1.1.</span> <span class="nav-text">日期相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#date"><span class="nav-number">1.1.1.</span> <span class="nav-text">Date</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java.util.date"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">java.util.Date</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%85%B6%E5%AE%83%E5%B7%B2%E8%BF%87%E6%97%B6"><span class="nav-number">1.1.1.1.1.</span> <span class="nav-text">两个常用构造器(其它已过时)：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java.sql.date"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">java.sql.Date</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java.text.simpledateformat"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">java.text.SimpleDateFormat</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">两个构造器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java.util.calendar"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">java.util.Calendar</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.1.4.1.</span> <span class="nav-text">获取实例的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="nav-number">1.1.1.4.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk8%E6%96%B0%E5%A2%9E%E7%9A%84%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api%E5%90%B8%E6%94%B6%E7%9A%84joda-time%E7%9A%84"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">jdk8新增的常用日期时间API(吸收的Joda-Time的)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9Flocaldate"><span class="nav-number">1.1.1.5.1.</span> <span class="nav-text">本地日期LocalDate</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.1.1.5.1.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="nav-number">1.1.1.5.1.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4localtime"><span class="nav-number">1.1.1.5.2.</span> <span class="nav-text">本地时间LocalTime</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-1"><span class="nav-number">1.1.1.5.2.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-4"><span class="nav-number">1.1.1.5.2.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4localdatetime"><span class="nav-number">1.1.1.5.3.</span> <span class="nav-text">本地日期时间LocalDateTime</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9E%AC%E6%97%B6instant"><span class="nav-number">1.1.1.5.4.</span> <span class="nav-text">瞬时Instant</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-2"><span class="nav-number">1.1.1.5.4.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-5"><span class="nav-number">1.1.1.5.4.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8E%E8%A7%A3%E6%9E%90java.time.format.datetimeformatter"><span class="nav-number">1.1.1.5.5.</span> <span class="nav-text">日期时间格式化与解析java.time.format.DateTimeFormatter</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-3"><span class="nav-number">1.1.1.5.5.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-6"><span class="nav-number">1.1.1.5.5.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">1.1.1.5.6.</span> <span class="nav-text">其它</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.</span> <span class="nav-text">注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.1.</span> <span class="nav-text">jdk内置的三个基本注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.2.</span> <span class="nav-text">自定义注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk%E6%8F%90%E4%BE%9B%E7%9A%844%E7%A7%8D%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.3.3.</span> <span class="nav-text">jdk提供的4种元注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk8%E6%B3%A8%E8%A7%A3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.4.</span> <span class="nav-text">jdk8注解新特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.4.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#properties"><span class="nav-number">1.4.1.</span> <span class="nav-text">Properties</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.1.</span> <span class="nav-text">自定义泛型结构：泛型类、泛型接口、泛型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#io%E6%B5%81"><span class="nav-number">1.6.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java.io.file%E7%B1%BB"><span class="nav-number">1.6.1.</span> <span class="nav-text">java.io.File类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-4"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-7"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%B5%81-1"><span class="nav-number">1.6.2.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filereader"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">FileReader</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-5"><span class="nav-number">1.6.2.1.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-8"><span class="nav-number">1.6.2.1.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filewriter"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">FileWriter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-6"><span class="nav-number">1.6.2.2.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-9"><span class="nav-number">1.6.2.2.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inputstream"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">InputStream</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-7"><span class="nav-number">1.6.2.3.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-10"><span class="nav-number">1.6.2.3.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#outputstream"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">OutputStream</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-8"><span class="nav-number">1.6.2.4.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-11"><span class="nav-number">1.6.2.4.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bufferedreaderbufferedwriter"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">BufferedReader&#x2F;BufferedWriter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bufferedinputstreambufferedinputstream"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">BufferedInputStream&#x2F;BufferedInputStream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81inputstreamreaderoutputstreamwriter"><span class="nav-number">1.6.2.7.</span> <span class="nav-text">转换流InputStreamReader、OutputStreamWriter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%B8%B8%E7%94%A8%E6%B5%81"><span class="nav-number">1.6.2.8.</span> <span class="nav-text">不常用流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%B5%81"><span class="nav-number">1.6.2.8.1.</span> <span class="nav-text">标准流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">1.6.2.8.2.</span> <span class="nav-text">打印流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">1.6.2.8.3.</span> <span class="nav-text">数据流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="nav-number">1.6.2.8.4.</span> <span class="nav-text">对象流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">1.6.2.8.5.</span> <span class="nav-text">随机存取文件流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#nio%E4%B8%AD%E7%9A%84pathpathsfiles"><span class="nav-number">1.6.2.8.6.</span> <span class="nav-text">NIO中的Path、Paths、Files</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.7.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ip%E5%9C%B0%E5%9D%80inetaddress"><span class="nav-number">1.7.1.</span> <span class="nav-text">IP地址InetAddress</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-9"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-12"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket"><span class="nav-number">1.7.2.</span> <span class="nav-text">Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-10"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-13"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#serversocket"><span class="nav-number">1.7.3.</span> <span class="nav-text">ServerSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-11"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-14"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#datagramsocket"><span class="nav-number">1.7.4.</span> <span class="nav-text">DatagramSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-12"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-15"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#url%E7%BC%96%E7%A8%8B"><span class="nav-number">1.7.5.</span> <span class="nav-text">URL编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">1.8.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96class%E5%AE%9E%E4%BE%8B%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.1.</span> <span class="nav-text">获取Class实例的4种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8classloader%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">1.8.2.</span> <span class="nav-text">使用ClassLoader加载配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.8.3.</span> <span class="nav-text">反射作用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">创建运行时类的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%A4%9A"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">获取运行时类的属性(开发中使用不多)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">获取运行时类的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.8.3.4.</span> <span class="nav-text">获取运行时构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E5%8F%8A%E7%88%B6%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.8.3.5.</span> <span class="nav-text">获取运行时类的父类及父类的泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%89%80%E5%9C%A8%E5%8C%85%E6%B3%A8%E8%A7%A3%E7%AD%89"><span class="nav-number">1.8.3.6.</span> <span class="nav-text">获取运行时类的接口、所在包、注解等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.8.3.7.</span> <span class="nav-text">调用运行时类中的指定属性、方法、构造器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.8.4.</span> <span class="nav-text">反射的应用：动态代理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.9.</span> <span class="nav-text">Java 8新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.9.1.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8Ffunctional%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.9.2.</span> <span class="nav-text">函数式(Functional)接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java%E5%86%85%E7%BD%AE%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">Java内置的四大核心函数式接口：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%86%85%E7%BD%AE%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">其它内置接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="nav-number">1.9.3.</span> <span class="nav-text">方法引用与构造器引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stream-api"><span class="nav-number">1.9.4.</span> <span class="nav-text">Stream API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%9A%84stream"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">创建的Stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stream%E7%9A%84%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">Stream的中间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%9B%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87"><span class="nav-number">1.9.4.2.1.</span> <span class="nav-text">1、筛选与切片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%A0%E5%B0%84"><span class="nav-number">1.9.4.2.2.</span> <span class="nav-text">2、映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">1.9.4.2.3.</span> <span class="nav-text">3、排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stream%E7%9A%84%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">1.9.4.3.</span> <span class="nav-text">Stream的终止操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE"><span class="nav-number">1.9.4.3.1.</span> <span class="nav-text">1、匹配与查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%92%E7%BA%A6"><span class="nav-number">1.9.4.3.2.</span> <span class="nav-text">2、归约</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B6%E9%9B%86"><span class="nav-number">1.9.4.3.3.</span> <span class="nav-text">3、收集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#optional"><span class="nav-number">1.9.5.</span> <span class="nav-text">Optional</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zephon"
      src="/blog/images/avatar1.gif">
  <p class="site-author-name" itemprop="name">Zephon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives">
          <span class="site-state-item-count">217</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zephon-H" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zephon-H" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/blog/qq1528498238@gmail.com" title="E-Mail → qq1528498238@gmail.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zephon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">20:18</span>
</div>

<br />
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/21/2019 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
