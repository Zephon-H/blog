<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
<meta name="referrer" content="no-referrer" />
<meta http-equiv="Content-Security-Policy" ontent="upgrade-insecure-requests">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.zephon.eu.org","root":"/blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="NoSQL 技术的分类  解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、MyBatis 解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis汇总">
<meta property="og:url" content="http://www.zephon.eu.org/blog/2022/09/10/Redis%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="Zephon Blog">
<meta property="og:description" content="NoSQL 技术的分类  解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、MyBatis 解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.zephon.ml/image-20220815101719372.png">
<meta property="og:image" content="http://image.zephon.ml/image-20220815101734622.png">
<meta property="og:image" content="http://image.zephon.ml/image-20220823232807718.png">
<meta property="og:image" content="http://image.zephon.ml/image-20220904100930848.png">
<meta property="article:published_time" content="2022-09-10T02:15:13.000Z">
<meta property="article:modified_time" content="2023-07-20T08:32:51.106Z">
<meta property="article:author" content="Zephon">
<meta property="article:tag" content="中间件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.zephon.ml/image-20220815101719372.png">

<link rel="canonical" href="http://www.zephon.eu.org/blog/2022/09/10/Redis%E6%B1%87%E6%80%BB/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis汇总 | Zephon Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?697784f78fd83128cc519aedf69e3017";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband">
	<a target="_blank" rel="noopener" href="https://github.com/Zephon-H" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
	</div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zephon Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-download">

    <a href="/blog/download/" rel="section"><i class="fa fa-download fa-fw"></i>下载</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.zephon.eu.org/blog/2022/09/10/Redis%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar1.gif">
      <meta itemprop="name" content="Zephon">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zephon Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-10 10:15:13" itemprop="dateCreated datePublished" datetime="2022-09-10T10:15:13+08:00">2022-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-20 16:32:51" itemprop="dateModified" datetime="2023-07-20T16:32:51+08:00">2023-07-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>43k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>39 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="nosql">NoSQL</h1>
<h2 id="技术的分类">技术的分类</h2>
<ul>
<li>解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</li>
<li>解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、MyBatis</li>
<li>解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</li>
</ul>
<h2 id="多服务器问题">多服务器问题</h2>
<h3 id="session存在哪">session存在哪？</h3>
<ol type="1">
<li>存在cookie里；不安全，且网络负担效率低</li>
<li>存在文件服务器或数据库里；大量的IO效率问题</li>
<li>session复制；session数据冗余，节点越多，浪费越大</li>
<li>缓存数据库；完成在内存中，速度快，数据结构简单</li>
</ol>
<h3 id="解决io压力">解决IO压力</h3>
<p>添加缓存数据库，减少IO的读操作</p>
<p>打破了传统关系型数据库以业务逻辑为依据的存储模式，而针对不同数据结构类型改为以性能最优先的存储方式。</p>
<h2 id="nosql概述">NoSQL概述</h2>
<p>NoSQL(NoSQL=Not Only SQL)，意即“不仅仅是SQL”，泛指<strong>非关系型数据库</strong></p>
<p>特点：</p>
<ul>
<li>不遵循SQL标准</li>
<li>不支持ACID</li>
<li>远超于SQL的性能</li>
</ul>
<p>适用场景：</p>
<ul>
<li>对数据高并发的读写</li>
<li>海量数据的读写</li>
<li>对数据高可扩展性的</li>
</ul>
<p>不适用场景：</p>
<ul>
<li>需要事务支持的</li>
<li>基于SQL结构化查询存储，处理复杂的关系</li>
</ul>
<h1 id="redis6概述">Redis6概述</h1>
<ul>
<li>Redis是一个开源的key-value存储系统</li>
<li>支持的存储类型包括：<strong>string</strong>(字符串)、<strong>list</strong>(链表)、<strong>set</strong>(集合)、<strong>zset</strong>(sorted set，有序集合)和<strong>hash</strong>(哈希类型)</li>
<li>这些数据类型都支持push/pop、add/remove及取交集并集及更丰富的操作，且这些操作都是<strong>原子性</strong>的</li>
<li>Redis支持各种不同方式的<strong>排序</strong></li>
<li>Redis<strong>数据缓存在内存</strong>中</li>
<li>Redis会<strong>周期性</strong>的把更新的<strong>数据写入磁盘</strong>或把修改操作写入追加的记录文件</li>
<li>在此基础上实现了<strong>master-slave(主从)</strong>同步</li>
</ul>
<h2 id="应用场景">应用场景</h2>
<ul>
<li>配合关系型数据库做高速缓存
<ul>
<li>高频次、热门访问的数据，降低数据库IO</li>
<li>分布式架构，做session共享</li>
</ul></li>
<li>多样的数据结构存储持久化数据
<ul>
<li>最新N个数据-------&gt;通过List实现自然时间排序的数据</li>
<li>排行榜，Top N-------&gt;利用zset(有序集合)</li>
<li>时效性数据如手机验证码-------&gt;Expire过期</li>
<li>计数器，秒杀-------&gt;原子性，自增方法INCR、DECR</li>
<li>去除大量数据中的重复数据-------&gt;利用set集合</li>
<li>构建队列-------&gt;利用list集合</li>
<li>发布订阅消息系统-------&gt;pub/sub模式</li>
</ul></li>
</ul>
<h2 id="安装">安装</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redis</span><br></pre></td></tr></table></figure>
<h3 id="安装目录">安装目录</h3>
<ul>
<li>redis-benchmark：性能测试工具</li>
<li>redis-check-aof：修复有问题的AOF文件</li>
<li>redis-check-dump：修复有问题的dump.rdb文件</li>
<li>redis-sentinel：Redis集群使用</li>
<li>redis-server：Redis服务器启动命令</li>
<li>redis-cli：客户端，操作入口</li>
</ul>
<h2 id="启动">启动</h2>
<h3 id="前台启动不推荐">前台启动(不推荐)</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<h3 id="后台启动推荐">后台启动(推荐)</h3>
<ol type="1">
<li><p>备份配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/redis/redis.conf redis.conf.bak</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件中的daemonize，如果为no则改为<strong>yes</strong></p></li>
<li><p>启动redis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/redis-server start</span><br></pre></td></tr></table></figure></li>
<li><p>客户端访问测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其它">其它</h2>
<ul>
<li>Redis默认16个数据库，下标从0开始，默认使用0号库</li>
<li>使用<code>select &lt;dbid&gt;</code>切换数据库，如：select 8</li>
<li>所有库使用同样密码</li>
<li>使用<code>dbsize</code>查看当前数据库的key的数量</li>
<li><code>flushdb</code>清空当前库</li>
<li><code>flushall</code>通杀全部库</li>
</ul>
<p>Redis是单线程+多路IO复用技术</p>
<h1 id="五大数据类型">五大数据类型</h1>
<h2 id="相关命令">相关命令</h2>
<ul>
<li><code>keys *</code>：查看当前库所有key</li>
<li><code>exists key</code>：判断某个key是否存在</li>
<li><code>type key</code>：查看key是什么类型</li>
<li><code>del key</code>：删除指定的key数据</li>
<li><font color="red"><code>unlink key</code>：根据key选择非阻塞删除</font>，仅将key从keyspace元数据中删除，真正的删除会在后续异步操作</li>
<li><code>expire key t</code> ：为给定的key设置过期时间为t</li>
<li><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已经过期</li>
<li><code>select &lt;dbid&gt;</code>：切换数据库</li>
<li><code>dbsize</code>：查看当前数据库的key的数量</li>
<li><code>flushdb</code>：清空当前数据库</li>
<li><code>flushall</code>：清空全部库</li>
</ul>
<h2 id="字符串string">字符串(String)</h2>
<h3 id="常用命令">常用命令</h3>
<ul>
<li><code>set &lt;key&gt; &lt;value&gt;</code>：向数据库中添加数据</li>
<li><code>get &lt;key&gt;</code>：查询对应键值</li>
<li><code>append &lt;key&gt; &lt;value&gt;</code>：将给定value追加到原值的末尾</li>
<li><code>strlen &lt;key&gt;</code>：获取值的长度</li>
<li><code>setnx &lt;key&gt; &lt;value&gt;</code>：只有在key不存在时，设置key的值</li>
<li><code>incr &lt;key&gt;</code>：将key中储存的数字值增1，只能对数字值操作，如果为空，新增值为1</li>
<li><code>decr &lt;key&gt;</code>：将key中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1</li>
<li><code>incrby &lt;key&gt; &lt;步长&gt;</code>：将key中储存的数字值增长，自定义步长</li>
<li><code>decrby &lt;key&gt; &lt;步长&gt;</code>：将key中储存的数字值减少，自定义步长</li>
</ul>
<blockquote>
<p>注：<code>incr &lt;key&gt;</code>：对存储在指定key的数字值执行<strong>原子</strong>的加1操作</p>
<p>所谓<strong>原子</strong>操作指的是不会被线程调度机制打断的操作</p>
<p>这种操作一旦开始，就一起运行到结束，中间不会有任何context switch(切换到另一个线程)</p>
<ol type="1">
<li>在单线程中，能够在单条指令中完成的操作都可以认为是原子操作，因为中断只能发生于指令之间</li>
<li>在多线程中，不能被其它进程(线程)打断的操作就叫原子操作</li>
</ol>
</blockquote>
<ul>
<li><p><code>mset &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;...</code>：同时设置一个或多个key-value对</p></li>
<li><p><code>mget &lt;key1&gt; &lt;key2&gt; ...</code>：同时获取一个或多个value</p></li>
<li><p><code>msetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;...</code>：同时设置一个或多个key-value对，当且仅当所有给定key都不存在时</p></li>
<li><p><code>getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</code>：获取值的范围，类似java中的substring，前包括，后包括，即范围是<strong>[起始，结束]</strong></p></li>
<li><p><code>setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</code>：用value覆写key所储存的字符串值，从起始位置开始(索引从0开始)</p></li>
<li><p><code>setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒</p></li>
<li><p><code>getset &lt;key&gt; &lt;value&gt;</code>：以新换旧，设置了新值同时获取得旧值</p></li>
</ul>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>String的数据结构为简单动态字符串(Simple Dynamic String，缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预先分配冗余空间的方式来减少内存的频繁分配</li>
<li>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间，需要注意的是字符串大小最大长度为512M</li>
</ul>
<h2 id="列表list">列表(List)</h2>
<h3 id="常用命令-1">常用命令</h3>
<ul>
<li><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt;...</code>：从左边/右边插入一个或多个值</li>
<li><code>lpop/rpop &lt;key&gt;</code>：从左边/右边弹出一个值，值在键在，值无键无</li>
<li><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从key1列表右边弹出一个值，插入到key2列表左边</li>
<li><code>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code>：按照索引下标获得元素(从左到右)，-1表示右边第一个</li>
<li><code>lindex &lt;key&gt; &lt;index&gt;</code>：按照索引下标获取元素(从左到右)</li>
<li><code>llen &lt;key&gt;</code>：获得列表长度</li>
<li><code>linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt;</code>：在value前面/后面插入newvalue</li>
<li><code>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</code>：从左边删除n个value(从左到右)</li>
<li><code>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</code>：将列表key下标为index的值替换成value</li>
</ul>
<h3 id="数据结构-1">数据结构</h3>
<ul>
<li>List的数据结构是快速链表quickList</li>
<li>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，即压缩列表，将所有的元素紧挨着一起存储，分配的是一块连续的内存</li>
<li>当数据量较多时才会改成quickList</li>
<li>因为普通的链表需要的附加指针空间太大，会比较浪费空间。如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next</li>
<li>Redis将链表和ziplist结合起来组成了quicklist，也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余</li>
</ul>
<h2 id="集合set">集合(Set)</h2>
<h3 id="常用命令-2">常用命令</h3>
<ul>
<li><code>sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ...</code>：将一个或多个元素加入到集合key中，已经存在的元素将被忽略</li>
<li><code>smember &lt;key&gt;</code>：取出该集合的所有值</li>
<li><code>sismember &lt;key&gt; &lt;value&gt;</code>：判断集合key是否含有该value值，有1，没有0</li>
<li><code>scard &lt;key&gt; &lt;value&gt;</code>：返回该集合的元素个数</li>
<li><code>srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt;...</code>：删除集合中的某个元素</li>
<li><code>spop &lt;key&gt;</code>：随机从该集合中弹出一个值</li>
<li><code>srandmember &lt;key&gt; &lt;n&gt;</code>：随机从该集合中取出n个值，不会从集合中删除</li>
<li><code>smove &lt;source&gt; &lt;dest&gt; value</code>：把集合中的一个值从source集合移动到dest集合</li>
<li><code>sinter &lt;key1&gt; &lt;key2&gt;</code>：返回两个集合的<strong>交集</strong>元素</li>
<li><code>sunion &lt;key1&gt; &lt;key2&gt;</code>：返回两个集合的<strong>并集</strong>元素</li>
<li><code>sdiff &lt;key1&gt; &lt;key2&gt;</code>：返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</li>
</ul>
<h3 id="数据结构-2">数据结构</h3>
<ul>
<li>Set数据结构是dict字典，字典是用哈希表实现的</li>
<li>Redis的set结构的内部也使用hash结构，所有的value都指向同一个内部值</li>
</ul>
<h2 id="哈希hash">哈希(Hash)</h2>
<h3 id="简介">简介</h3>
<p>hash存储对象结构的三种方式：</p>
<ol type="1">
<li>key：用户ID；value：序列化的value对象</li>
<li>key：用户ID+标签；value：标签对应数据</li>
<li>key：用户ID；Hash：field(标签)，value(标签对应数据)</li>
</ol>
<h3 id="常用命令-3">常用命令</h3>
<ul>
<li><code>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code>：给key集合中的field键赋值value</li>
<li><code>hget &lt;key1&gt; &lt;field&gt;</code>：从key1集合field取出value</li>
<li><code>hmset &lt;key1&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt; ...</code>：批量设置hash的值，现由<code>hset</code>代替</li>
<li><code>hexists &lt;key1&gt; &lt;field&gt;</code>：查看哈希表key中，给定域field是否存在</li>
<li><code>hkeys &lt;key&gt;</code>：列出该hash集合的所有field</li>
<li><code>hvals &lt;key&gt;</code>：列出该hash集合的所有value</li>
<li><code>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</code>：为哈希表key中的域field的值加上增量1</li>
<li><code>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</code>：将哈希表key中的域field的值设置为value，当且仅当域field不存在</li>
</ul>
<h3 id="数据结构-3">数据结构</h3>
<ul>
<li>Hash类型对应的数据结构是两种：ziplist(压缩列表)，hashtable(哈希表)</li>
<li>当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</li>
</ul>
<h2 id="有序集合zset">有序集合Zset</h2>
<h3 id="常用命令-4">常用命令</h3>
<ul>
<li><code>zadd &lt;key&gt; &lt;score1&gt; &lt;value1&gt; &lt;score2&gt; &lt;value2&gt;...</code>：将一个或多个member元素及其score值加入到有序集key中</li>
<li><code>zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [withscores]</code>：返回有序集key中，下标在start和stop之间的元素，带withscores，可以让分数一起和值返回到结果集</li>
<li><code>zrangebyscore key min max [withscores] [limit offset count]</code>：返回有序集key中，所有score值介于min和max之间(包括等于min和max)的成员。有序集成员按score值递增(从小到大)次序排列</li>
<li><code>zrevrangebyscore key max min [withscores] [limit offset count]</code>：同上，改为从大到小排序</li>
<li><code>zincrby &lt;key&gt; &lt;increment&gt; &lt;value&gt;</code>：为元素的score加上增量</li>
<li><code>zrem &lt;key&gt; &lt;value&gt;</code>：删除该集合下，指定值的元素</li>
<li><code>zcount &lt;key&gt; &lt;min&gt; &lt;max&gt;</code>：统计该集合分数区间内的元素个数</li>
<li><code>zrank &lt;key&gt; &lt;value&gt;</code>：返回该值在集合中的排名，从0开始</li>
</ul>
<h3 id="数据结构-4">数据结构</h3>
<ul>
<li>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</li>
<li>zset底层使用了两个数据结构：
<ol type="1">
<li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值</li>
<li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表</li>
</ol></li>
</ul>
<h1 id="redis6配置文件常用配置详解">Redis6配置文件常用配置详解</h1>
<h2 id="units-单位">1、Units 单位</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Redis configuration file example.</span><br><span class="line">#</span><br><span class="line"># Note that in order to read the configuration file, Redis must be</span><br><span class="line"># started with the file path as first argument:</span><br><span class="line">#</span><br><span class="line"># ./redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br></pre></td></tr></table></figure>
<p>配置大小单位，开头定义了一些基本的度量单位，只支持bytes，不支持bit，大小写不敏感</p>
<h2 id="includes包含">2、INCLUDES包含</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">################################## INCLUDES ###################################</span><br><span class="line"></span><br><span class="line"># Include one or more other config files here.  This is useful if you</span><br><span class="line"># have a standard template that goes to all Redis servers but also need</span><br><span class="line"># to customize a few per-server settings.  Include files can include</span><br><span class="line"># other files, so use this wisely.</span><br><span class="line">#</span><br><span class="line"># Notice option &quot;include&quot; won&#x27;t be rewritten by command &quot;CONFIG REWRITE&quot;</span><br><span class="line"># from admin or Redis Sentinel. Since Redis always uses the last processed</span><br><span class="line"># line as value of a configuration directive, you&#x27;d better put includes</span><br><span class="line"># at the beginning of this file to avoid overwriting config change at runtime.</span><br><span class="line">#</span><br><span class="line"># If instead you are interested in using includes to override configuration</span><br><span class="line"># options, it is better to use include as the last line.</span><br><span class="line">#</span><br><span class="line"># include /path/to/local.conf</span><br><span class="line"># include /path/to/other.conf</span><br></pre></td></tr></table></figure>
<p>类似于C、C++中的include，多实例的情况可以把公用的配置文件提取出来</p>
<h2 id="网络相关配置">3、网络相关配置</h2>
<h3 id="bind">3.1、bind</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">################################## NETWORK #####################################</span><br><span class="line"></span><br><span class="line"># By default, if no &quot;bind&quot; configuration directive is specified, Redis listens</span><br><span class="line"># for connections from all the network interfaces available on the server.</span><br><span class="line"># It is possible to listen to just one or multiple selected interfaces using</span><br><span class="line"># the &quot;bind&quot; configuration directive, followed by one or more IP addresses.</span><br><span class="line">#</span><br><span class="line"># Examples:</span><br><span class="line">#</span><br><span class="line"># bind 192.168.1.100 10.0.0.1</span><br><span class="line"># bind 127.0.0.1 ::1</span><br><span class="line">#</span><br><span class="line"># ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span><br><span class="line"># internet, binding to all the interfaces is dangerous and will expose the</span><br><span class="line"># instance to everybody on the internet. So by default we uncomment the</span><br><span class="line"># following bind directive, that will force Redis to listen only into</span><br><span class="line"># the IPv4 loopback interface address (this means Redis will be able to</span><br><span class="line"># accept connections only from clients running into the same computer it</span><br><span class="line"># is running).</span><br><span class="line">#</span><br><span class="line"># IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span><br><span class="line"># JUST COMMENT THE FOLLOWING LINE.</span><br><span class="line">bind 127.0.0.1 ::1</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下bind=127.0.0.1只能接受本机的访问请求</li>
<li>不写的情况下，无限制接受任何ip地址的访问</li>
<li>生产环境肯定要写应用服务器的地址；服务器需要远程访问，所以需要将其注释掉</li>
<li><font color="red">如果开启了<code>protected-mode</code>，则在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</font></li>
</ul>
<h3 id="protected-mode">3.2、protected-mode</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Protected mode is a layer of security protection, in order to avoid that</span><br><span class="line"># Redis instances left open on the internet are accessed and exploited.</span><br><span class="line">#</span><br><span class="line"># When protected mode is on and if:</span><br><span class="line">#</span><br><span class="line"># 1) The server is not binding explicitly to a set of addresses using the</span><br><span class="line">#    &quot;bind&quot; directive.</span><br><span class="line"># 2) No password is configured.</span><br><span class="line">#</span><br><span class="line"># The server only accepts connections from clients connecting from the</span><br><span class="line"># IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain</span><br><span class="line"># sockets.</span><br><span class="line">#</span><br><span class="line"># By default protected mode is enabled. You should disable it only if</span><br><span class="line"># you are sure you want clients from other hosts to connect to Redis</span><br><span class="line"># even if no authentication is configured, nor a specific set of interfaces</span><br><span class="line"># are explicitly listed using the &quot;bind&quot; directive.</span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure>
<ul>
<li>本机访问保护模式，默认为yes，表示本机能访问而远程不能访问</li>
</ul>
<h3 id="port">3.3、 Port</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Accept connections on the specified port, default is 6379 (IANA #815344).</span><br><span class="line"># If port 0 is specified Redis will not listen on a TCP socket.</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure>
<ul>
<li>端口号，默认是6379</li>
</ul>
<h3 id="tcp-backlog">3.4、tcp-backlog</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># TCP listen() backlog.</span><br><span class="line">#</span><br><span class="line"># In high requests-per-second environments you need an high backlog in order</span><br><span class="line"># to avoid slow clients connections issues. Note that the Linux kernel</span><br><span class="line"># will silently truncate it to the value of /proc/sys/net/core/somaxconn so</span><br><span class="line"># make sure to raise both the value of somaxconn and tcp_max_syn_backlog</span><br><span class="line"># in order to get the desired effect.</span><br><span class="line">tcp-backlog 511</span><br></pre></td></tr></table></figure>
<ul>
<li>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列+已经完成三次握手队列</li>
<li>在高并发环境下需要一个高backlog值来避免慢客户端连接问题</li>
<li>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值(128)，所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog(128)两个值来达到想要的效果</li>
</ul>
<h3 id="timeout">3.5、timeout</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Unix socket.</span><br><span class="line">#</span><br><span class="line"># Specify the path for the Unix socket that will be used to listen for</span><br><span class="line"># incoming connections. There is no default, so Redis will not listen</span><br><span class="line"># on a unix socket when not specified.</span><br><span class="line">#</span><br><span class="line"># unixsocket /var/run/redis/redis-server.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line"></span><br><span class="line"># Close the connection after a client is idle for N seconds (0 to disable)</span><br><span class="line">timeout 0</span><br></pre></td></tr></table></figure>
<ul>
<li>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即<strong>永不关闭</strong></li>
</ul>
<h3 id="tcp-keepalive">3.6 tcp-keepalive</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># TCP keepalive.</span><br><span class="line">#</span><br><span class="line"># If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence</span><br><span class="line"># of communication. This is useful for two reasons:</span><br><span class="line">#</span><br><span class="line"># 1) Detect dead peers.</span><br><span class="line"># 2) Take the connection alive from the point of view of network</span><br><span class="line">#    equipment in the middle.</span><br><span class="line">#</span><br><span class="line"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span><br><span class="line"># Note that to close the connection the double of the time is needed.</span><br><span class="line"># On other kernels the period depends on the kernel configuration.</span><br><span class="line">#</span><br><span class="line"># A reasonable value for this option is 300 seconds, which is the new</span><br><span class="line"># Redis default starting with Redis 3.2.1.</span><br><span class="line">tcp-keepalive 300</span><br></pre></td></tr></table></figure>
<ul>
<li>对访问客户端的一种心跳检测，每隔n秒检测一次</li>
<li>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</li>
</ul>
<h2 id="general通用">4、GENERAL通用</h2>
<h3 id="daemonize">4.1、daemonize</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">################################# GENERAL #####################################</span><br><span class="line"></span><br><span class="line"># By default Redis does not run as a daemon. Use &#x27;yes&#x27; if you need it.</span><br><span class="line"># Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>
<ul>
<li>是否为守护进程</li>
</ul>
<h3 id="pidfile">4.2、pidfile</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># If a pid file is specified, Redis writes it where specified at startup</span><br><span class="line"># and removes it at exit.</span><br><span class="line">#</span><br><span class="line"># When the server runs non daemonized, no pid file is created if none is</span><br><span class="line"># specified in the configuration. When the server is daemonized, the pid file</span><br><span class="line"># is used even if not specified, defaulting to &quot;/var/run/redis.pid&quot;.</span><br><span class="line">#</span><br><span class="line"># Creating a pid file is best effort: if Redis is not able to create it</span><br><span class="line"># nothing bad happens, the server will start and run normally.</span><br><span class="line">pidfile /var/run/redis/redis-server.pid</span><br></pre></td></tr></table></figure>
<ul>
<li>存放pid文件的位置，每个实例会产生一个不同的pid文件</li>
</ul>
<h3 id="loglevel">4.3、loglevel</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Specify the server verbosity level.</span><br><span class="line"># This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development/testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably)</span><br><span class="line"># warning (only very important / critical messages are logged)</span><br><span class="line">loglevel notice</span><br></pre></td></tr></table></figure>
<ul>
<li>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认是notice</li>
<li>四个级别根据使用阶段来选择，生产环境选择notice或warning</li>
</ul>
<h3 id="logfile">4.4、logfile</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Specify the log file name. Also the empty string can be used to force</span><br><span class="line"># Redis to log on the standard output. Note that if you use standard</span><br><span class="line"># output for logging but daemonize, logs will be sent to /dev/null</span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br><span class="line"># To enable logging to the system logger, just set &#x27;syslog-enabled&#x27; to yes,</span><br><span class="line"># and optionally update the other syslog parameters to suit your needs.</span><br><span class="line"># syslog-enabled no</span><br><span class="line"></span><br><span class="line"># Specify the syslog identity.</span><br><span class="line"># syslog-ident redis</span><br><span class="line"></span><br><span class="line"># Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.</span><br><span class="line"># syslog-facility local0</span><br></pre></td></tr></table></figure>
<ul>
<li>日志文件名称</li>
</ul>
<h3 id="databases-16">4.5、databases 16</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Set the number of databases. The default database is DB 0, you can select</span><br><span class="line"># a different one on a per-connection basis using SELECT &lt;dbid&gt; where</span><br><span class="line"># dbid is a number between 0 and &#x27;databases&#x27;-1</span><br><span class="line">databases 16</span><br></pre></td></tr></table></figure>
<ul>
<li>设定库的数量，默认为16，默认数据库为0，可以使用<code>select &lt;dbid&gt;</code>命令在连接上指定数据库id</li>
</ul>
<h2 id="security安全">5、SECURITY安全</h2>
<h3 id="设置密码">5.1、设置密码</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">################################## SECURITY ###################################</span><br><span class="line"></span><br><span class="line"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span><br><span class="line"># commands.  This might be useful in environments in which you do not trust</span><br><span class="line"># others with access to the host running redis-server.</span><br><span class="line">#</span><br><span class="line"># This should stay commented out for backward compatibility and because most</span><br><span class="line"># people do not need auth (e.g. they run their own servers).</span><br><span class="line">#</span><br><span class="line"># Warning: since Redis is pretty fast an outside user can try up to</span><br><span class="line"># 150k passwords per second against a good box. This means that you should</span><br><span class="line"># use a very strong password otherwise it will be very easy to break.</span><br><span class="line">#</span><br><span class="line"># requirepass foobared</span><br></pre></td></tr></table></figure>
<ul>
<li>访问密码的查看、设置和取消</li>
<li>可通过命令设置密码，但这样只是临时的，重启redis服务器就会还原
<ul>
<li><code>config get requirepass</code>：</li>
<li><code>config set requirepass &lt;password&gt;</code>：</li>
<li><code>auth &lt;password&gt;</code>：</li>
</ul></li>
<li>永久设置需要在配置文件中配置</li>
</ul>
<h2 id="clients">6、CLIENTS</h2>
<h3 id="maxclients">6.1、maxclients</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Set the max number of connected clients at the same time. By default</span><br><span class="line"># this limit is set to 10000 clients, however if the Redis server is not</span><br><span class="line"># able to configure the process file limit to allow for the specified limit</span><br><span class="line"># the max number of allowed clients is set to the current file limit</span><br><span class="line"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span><br><span class="line">#</span><br><span class="line"># Once the limit is reached Redis will close all the new connections sending</span><br><span class="line"># an error &#x27;max number of clients reached&#x27;.</span><br><span class="line">#</span><br><span class="line"># maxclients 10000</span><br></pre></td></tr></table></figure>
<ul>
<li>设置redis同时可以与多少客户端进行连接</li>
<li>默认情况下为10000个客户端</li>
<li>如果达到了此限制，redis会拒绝新的连接请求，并且向这些连接请求方发出"max number of clients reached"作为回应</li>
</ul>
<h2 id="memory-management">7、MEMORY MANAGEMENT</h2>
<h3 id="maxmemory">7.1、maxmemory</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">############################## MEMORY MANAGEMENT ################################</span><br><span class="line"></span><br><span class="line"># Set a memory usage limit to the specified amount of bytes.</span><br><span class="line"># When the memory limit is reached Redis will try to remove keys</span><br><span class="line"># according to the eviction policy selected (see maxmemory-policy).</span><br><span class="line">#</span><br><span class="line"># If Redis can&#x27;t remove keys according to the policy, or if the policy is</span><br><span class="line"># set to &#x27;noeviction&#x27;, Redis will start to reply with errors to commands</span><br><span class="line"># that would use more memory, like SET, LPUSH, and so on, and will continue</span><br><span class="line"># to reply to read-only commands like GET.</span><br><span class="line">#</span><br><span class="line"># This option is usually useful when using Redis as an LRU or LFU cache, or to</span><br><span class="line"># set a hard memory limit for an instance (using the &#x27;noeviction&#x27; policy).</span><br><span class="line">#</span><br><span class="line"># WARNING: If you have replicas attached to an instance with maxmemory on,</span><br><span class="line"># the size of the output buffers needed to feed the replicas are subtracted</span><br><span class="line"># from the used memory count, so that network problems / resyncs will</span><br><span class="line"># not trigger a loop where keys are evicted, and in turn the output</span><br><span class="line"># buffer of replicas is full with DELs of keys evicted triggering the deletion</span><br><span class="line"># of more keys, and so forth until the database is completely emptied.</span><br><span class="line">#</span><br><span class="line"># In short... if you have replicas attached it is suggested that you set a lower</span><br><span class="line"># limit for maxmemory so that there is some free RAM on the system for replica</span><br><span class="line"># output buffers (but this is not needed if the policy is &#x27;noeviction&#x27;).</span><br><span class="line">#</span><br><span class="line"># maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机</li>
<li>设置redis可以使用的内存量，一旦达到内存使用上限，redis会试图移除内部数据，移除规则可以通过maxmemory-policy来指定</li>
<li>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，则redis会针对那些需要申请内存的指令来返回错误信息，如：SET、LPUSH等</li>
<li>但对于无内存申请的指令，仍然会正常响应，如GET等。如果redis是主redis(说明有从redis)，则在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在设置的是”不移除“的情况下，才不用考虑这个因素</li>
</ul>
<h3 id="maxmemory-policy">7.2、maxmemory-policy</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"># is reached. You can select among five behaviors:</span><br><span class="line">#</span><br><span class="line"># volatile-lru -&gt; Evict using approximated LRU among the keys with an expire set.</span><br><span class="line"># allkeys-lru -&gt; Evict any key using approximated LRU.</span><br><span class="line"># volatile-lfu -&gt; Evict using approximated LFU among the keys with an expire set.</span><br><span class="line"># allkeys-lfu -&gt; Evict any key using approximated LFU.</span><br><span class="line"># volatile-random -&gt; Remove a random key among the ones with an expire set.</span><br><span class="line"># allkeys-random -&gt; Remove a random key, any key.</span><br><span class="line"># volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># noeviction -&gt; Don&#x27;t evict anything, just return an error on write operations.</span><br><span class="line">#</span><br><span class="line"># LRU means Least Recently Used</span><br><span class="line"># LFU means Least Frequently Used</span><br><span class="line">#</span><br><span class="line"># Both LRU, LFU and volatile-ttl are implemented using approximated</span><br><span class="line"># randomized algorithms.</span><br><span class="line">#</span><br><span class="line"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="line">#       operations, when there are no suitable keys for eviction.</span><br><span class="line">#</span><br><span class="line">#       At the date of writing these commands are: set setnx setex append</span><br><span class="line">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">#       getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># The default is:</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction</span><br></pre></td></tr></table></figure>
<ul>
<li>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键</li>
<li>allkeys-lru：在所有集合key中，使用LRU算法移除key</li>
<li>volatile-lfu：在过期集合中移除随机的key，只对设置了过期时间的键</li>
<li>allkeys-lfu：在所有集合key中，移除随机的key</li>
<li>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key</li>
<li>noeviction：不进行移除，针对写操作，只是返回错误信息</li>
</ul>
<h3 id="maxmemory-samples">7.3、maxmemory-samples</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="line"># used less recently, you can change the sample size using the following</span><br><span class="line"># configuration directive.</span><br><span class="line"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="line"># true LRU but costs more CPU. 3 is faster but not very accurate.</span><br><span class="line">#</span><br><span class="line"># maxmemory-samples 5</span><br></pre></td></tr></table></figure>
<ul>
<li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个</li>
<li>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小</li>
</ul>
<h1 id="redis6的发布与订阅">Redis6的发布与订阅</h1>
<h2 id="什么是发布和订阅">什么是发布和订阅</h2>
<ul>
<li>Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息</li>
<li>Redis客户端可以订阅任意数量的频道</li>
</ul>
<h2 id="redis的发布和订阅">Redis的发布和订阅</h2>
<ul>
<li><p>客户端可以订阅频道如图：</p>
<p><img src="http://image.zephon.ml/image-20220815101719372.png" /></p></li>
<li><p>当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<p><img src="http://image.zephon.ml/image-20220815101734622.png" /></p></li>
</ul>
<h2 id="发布订阅相关命令">发布订阅相关命令</h2>
<ul>
<li><code>subscribe &lt;channel&gt;</code>：订阅channel</li>
<li><code>publish &lt;channel&gt; &lt;message&gt;</code>：给频道channel发送消息message，返回值是订阅者数量</li>
</ul>
<h1 id="jedis操作redis6">Jedis操作Redis6</h1>
<h2 id="导包">1、导包</h2>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="使用">2、使用</h2>
<blockquote>
<p>注：连接前需要先修改配置文件并且放开6379端口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.1.27&quot;</span>, <span class="number">6379</span>);  <span class="comment">// 传入IP和端口号</span></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">String value = jedis.ping();</span><br><span class="line">System.out.println(value);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>
<h2 id="jedis常用api">Jedis常用API</h2>
<h3 id="key">Key</h3>
<ul>
<li><code>jedis.set("k1", "v1")</code></li>
<li><code>jedis.keys("*")</code></li>
<li><code>jedis.exists("k1")</code></li>
<li><code>jedis.ttl("k1")</code></li>
<li><code>jedis.get("k1")</code></li>
</ul>
<h3 id="string">String</h3>
<ul>
<li><code>jedis.mset("str1","v1","str2","v2")</code></li>
<li><code>jedis.mget("str1","str2")</code></li>
</ul>
<h3 id="list">List</h3>
<ul>
<li><code>jedis.lrange("mylist", 0, -1)</code></li>
</ul>
<h3 id="set">Set</h3>
<ul>
<li><code>jedis.sadd("orders", "order01")</code></li>
<li><code>jedis.smembers("orders")</code></li>
<li><code>jedis.srem("orders", "order01")</code></li>
</ul>
<h3 id="hash">Hash</h3>
<ul>
<li><code>jedis.hset("hash1", "userName", "Tom")</code></li>
<li><code>jedis.hget("hash1", "userName")</code></li>
<li><code>jedis.hmset("hash2", new HashMap&lt;String, String&gt;())</code></li>
<li><code>jedis.hmget("hash2", "telphone", "email")</code></li>
</ul>
<h3 id="zset">zset</h3>
<ul>
<li><code>jedis.zadd("zset01", 100d, "z3")</code></li>
<li><code>jedis.zrange("zset01", 0, -1)</code></li>
</ul>
<h1 id="springboot整合redis">SpringBoot整合Redis</h1>
<h2 id="导入依赖">1、导入依赖</h2>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置application.properties">2、配置application.properties</h2>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>
<h2 id="添加redis配置类">3、添加Redis配置类</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="redis6的事务操作">Redis6的事务操作</h1>
<ul>
<li>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行过程中，不会被其它客户端发送来的命令请求所打断</li>
<li>Redis事务的主要作用就是串联多个命令防止别的命令插队</li>
</ul>
<h2 id="multiexecdiscard">multi、exec、discard</h2>
<ul>
<li>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行</li>
<li>组队的过程中可以通过discard来放弃组队</li>
</ul>
<h2 id="事务的错误处理">事务的错误处理</h2>
<ul>
<li>组队中某个命令出了报告错误，执行时整个队列都会被取消</li>
<li>如果执行阶段某个命令出现错误，则只有报错的命令不会被执行，而其它命令都会执行，不会回滚</li>
</ul>
<h2 id="redis锁相关命令">Redis锁相关命令</h2>
<ul>
<li><code>watch key [key ...]</code>：在执行multi之前执行，可以监视一个(或多个)key，如果在事务执行之前这个(或这些)key被其它命令所改动，则事务会被打断</li>
<li><code>unwatch</code>：取消<code>watch</code>命令对所有key的监视，如果在执行<code>watch</code>之后，<code>exec</code>命令或<code>discard</code>命令先被执行，则不需要再执行<code>unwatch</code></li>
</ul>
<h2 id="redis事务三特性">Redis事务三特性</h2>
<ul>
<li>单独的隔离操作
<ul>
<li>事务中的所有命令都会序列化，按顺序地执行。事务在执行的过程中不会被其它客户端发送来的命令请求所打断</li>
</ul></li>
<li>没有隔离级别的概念
<ul>
<li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li>
</ul></li>
<li>不保证原子性
<ul>
<li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul></li>
</ul>
<h2 id="redis事务秒杀案例">Redis事务秒杀案例</h2>
<h3 id="模拟秒杀的工具">模拟秒杀的工具</h3>
<ol type="1">
<li><p>安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apache2-utils</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000 -c 100 http://127.0.0.1:8080/secKill</span><br><span class="line"><span class="meta">#</span><span class="bash"> -n：表示当前请求次数是</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -c：表示当前并发次数是</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -T：如果使用POST/PUT请求时需要设置content-type</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p：postfile，即post请求对应参数信息所存放的文件</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="业务实现">业务实现</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid, String productId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. uid和productId非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="keyword">null</span> || productId == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 2. 连接redis</span></span><br><span class="line">        <span class="comment">// 3. 拼接key</span></span><br><span class="line">        <span class="comment">// 3.1 库存key</span></span><br><span class="line">        String kcKey = <span class="string">&quot;sk:&quot;</span> + productId + <span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">        <span class="comment">// 3.2 秒杀成功用户key</span></span><br><span class="line">        String userKey = <span class="string">&quot;sk:&quot;</span> + productId + <span class="string">&quot;:user&quot;</span>;</span><br><span class="line">        <span class="comment">// 4. 获取库存，如果库存null，表示还没开始</span></span><br><span class="line">        <span class="comment">// 监视库存</span></span><br><span class="line">        List result = (List) redisTemplate.execute(<span class="keyword">new</span> SessionCallback&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">execute</span><span class="params">(RedisOperations operations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                operations.watch(kcKey);</span><br><span class="line">                Integer kc = (Integer) operations.opsForValue().get(kcKey);</span><br><span class="line">                <span class="keyword">if</span> (kc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;秒杀还没有开始&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 5. 判断用户是否重复秒杀操作</span></span><br><span class="line">                <span class="keyword">if</span> (operations.opsForSet().isMember(userKey, uid)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;已经秒杀成功了，不能重复秒杀！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 6. 判断如果库存数量小于1，秒杀结束</span></span><br><span class="line">                <span class="keyword">if</span> (kc &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;秒杀已经结束了&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                operations.multi();</span><br><span class="line">                <span class="comment">// 7. 秒杀操作</span></span><br><span class="line">                <span class="comment">// 7.1 库存-1</span></span><br><span class="line">                operations.opsForValue().decrement(kcKey);</span><br><span class="line">                <span class="comment">// 7.2 用户设置到清单</span></span><br><span class="line">                operations.opsForSet().add(userKey, uid);</span><br><span class="line">                <span class="keyword">return</span> operations.exec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//        System.out.println(result);</span></span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span> || result.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用lua解决库存遗留问题">使用Lua解决库存遗留问题</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProductService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid, String productId)</span> </span>&#123;</span><br><span class="line">        DefaultRedisScript redisScript = <span class="keyword">new</span> DefaultRedisScript();</span><br><span class="line">        redisScript.setResultType(String.class);</span><br><span class="line">        redisScript.setScriptSource(<span class="keyword">new</span> ResourceScriptSource(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;secKill.lua&quot;</span>)));</span><br><span class="line">        Integer result = (Integer) redisTemplate.execute(redisScript, Arrays.asList(uid, productId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (result) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;已抢空!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;抢购成功&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;该用户已抢过&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;抢购异常&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="lua脚本">lua脚本</h3>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> userid=KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> prodid=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> usersKey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:user&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> userExists=redis.call(<span class="string">&quot;sismember&quot;</span>,usersKey,userid);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(userExists)==<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> num= redis.call(<span class="string">&quot;get&quot;</span> ,qtkey);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(num)&lt;=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  redis.call(<span class="string">&quot;decr&quot;</span>,qtkey);</span><br><span class="line">  redis.call(<span class="string">&quot;sadd&quot;</span>,usersKey,userid);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="redis6持久化">Redis6持久化</h1>
<h2 id="rdbredis-database">RDB(Redis DataBase)</h2>
<h3 id="是什么">是什么</h3>
<ul>
<li>在<strong>指定的时间间隔内</strong>将内存中的数据集<strong>快照</strong>写入磁盘，也就是Snapshot快照，恢复时将快照文件读取到内存中</li>
</ul>
<h3 id="如何执行">如何执行</h3>
<ul>
<li>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据<strong>写入到一个临时文件</strong>中，待持久化过程结束了，再用这个<strong>临时文件替换上次持久化好的文件</strong>。整个过程中，主进程不进行任何IO操作，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，则RDB要比AOF方式更加的高效。</li>
<li>RDB的缺点是：<strong>最后一次持久化后的数据可能丢失</strong></li>
</ul>
<h3 id="fork">Fork</h3>
<ul>
<li>Fork的作用是复制一个目标与当前进程<strong>一样的进程</strong>，新进程的所有数据（变量、环境变量、程序计数器等）数值都会原进程一致，但是一个全新的进程，并作为<strong>原进程的子进程</strong></li>
<li>在Linux程序中，fork()会产生一个和父进程一样的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux引入了"<strong>写时复制技术</strong>"</li>
<li>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，都会将父进程的内容复制一份给子进程</li>
</ul>
<h3 id="相关配置">相关配置</h3>
<h3 id="dbfilename">dbfilename</h3>
<ul>
<li>设置持久化文件名称</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># The filename where to dump the DB</span><br><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure>
<h3 id="dir">dir</h3>
<ul>
<li>设置持久化文件路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># The working directory.</span><br><span class="line">#</span><br><span class="line"># The DB will be written inside this directory, with the filename specified</span><br><span class="line"># above using the &#x27;dbfilename&#x27; configuration directive.</span><br><span class="line">#</span><br><span class="line"># The Append Only File will also be created inside this directory.</span><br><span class="line">#</span><br><span class="line"># Note that you must specify a directory here, not a file name.</span><br><span class="line">dir /var/lib/redis</span><br></pre></td></tr></table></figure>
<h3 id="快照触发机制">快照触发机制</h3>
<ol type="1">
<li>配置文件中默认配置</li>
<li>命令save/bgsave
<ol type="1">
<li><code>save</code>：只管保存，其它不管，全部阻塞。手动保存，不建议</li>
<li><code>bgsave</code>：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求
<ul>
<li><code>lastsave</code>：获取最后一次成功执行快照的时间</li>
</ul></li>
</ol></li>
<li><code>flushall</code>也会触发快照，产生空的dump.rdb文件</li>
</ol>
<h3 id="snapshotting快照">SNAPSHOTTING：快照</h3>
<h4 id="save">save</h4>
<ul>
<li>默认是：
<ul>
<li>900秒(15分钟)内有至少一个key变化了</li>
<li>300秒(5分钟)内有至少10个key变化了</li>
<li>60秒内有至少10000个key变化了</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">################################ SNAPSHOTTING  ################################</span><br><span class="line">#</span><br><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<h4 id="stop-writes-on-bgsave-error">stop-writes-on-bgsave-error</h4>
<ul>
<li>当Redis无法写入磁盘的话，直接关掉Redis的写操作，默认yes，推荐yes</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># By default Redis will stop accepting writes if RDB snapshots are enabled</span><br><span class="line"># (at least one save point) and the latest background save failed.</span><br><span class="line"># This will make the user aware (in a hard way) that data is not persisting</span><br><span class="line"># on disk properly, otherwise chances are that no one will notice and some</span><br><span class="line"># disaster will happen.</span><br><span class="line">#</span><br><span class="line"># If the background saving process will start working again Redis will</span><br><span class="line"># automatically allow writes again.</span><br><span class="line">#</span><br><span class="line"># However if you have setup your proper monitoring of the Redis server</span><br><span class="line"># and persistence, you may want to disable this feature so that Redis will</span><br><span class="line"># continue to work as usual even if there are problems with disk,</span><br><span class="line"># permissions, and so forth.</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br></pre></td></tr></table></figure>
<h4 id="rdbcompression">rdbcompression</h4>
<ul>
<li>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。</li>
<li>如果不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Compress string objects using LZF when dump .rdb databases?</span><br><span class="line"># For default that&#x27;s set to &#x27;yes&#x27; as it&#x27;s almost always a win.</span><br><span class="line"># If you want to save some CPU in the saving child set it to &#x27;no&#x27; but</span><br><span class="line"># the dataset will likely be bigger if you have compressible values or keys.</span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>
<h4 id="rdbchecksum">rdbchecksum</h4>
<ul>
<li>在存储快照后，可以让redis使用CRC64算法进行数据校验</li>
<li>但这样会增加约10%的性能消耗，如果希望获得最大的性能提升可以关闭</li>
<li>推荐yes</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.</span><br><span class="line"># This makes the format more resistant to corruption but there is a performance</span><br><span class="line"># hit to pay (around 10%) when saving and loading RDB files, so you can disable it</span><br><span class="line"># for maximum performances.</span><br><span class="line">#</span><br><span class="line"># RDB files created with checksum disabled have a checksum of zero that will</span><br><span class="line"># tell the loading code to skip the check.</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>
<h3 id="备份与恢复">备份与恢复</h3>
<h4 id="备份">备份</h4>
<ol type="1">
<li>通过配置文件查看rdb文件位置</li>
<li>将rdb文件拷贝到其它地方</li>
</ol>
<h4 id="恢复">恢复</h4>
<ol type="1">
<li>关闭Redis</li>
<li>将备份文件拷贝到工作目录下</li>
<li>启动Redis，备份数据会直接加载</li>
</ol>
<h3 id="rdb优劣势">RDB优劣势</h3>
<p>优势：</p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据完整性和一致性要求不高时更适合使用</li>
<li>节省磁盘空间</li>
<li>恢复速度快</li>
</ul>
<p>劣势：</p>
<ul>
<li>Fork时，内存中的数据被克隆一份，大致2倍的膨胀性需要考虑</li>
<li>虽然Redis在fork时使用了写时复制技术，但如果数据庞大时还是比较消耗性能</li>
<li>一定时间间隔做一次备份，所以如果Redis意外宕掉就会丢失最后一次快照后的所有修改</li>
</ul>
<h3 id="如何停止使用rdb">如何停止使用RDB</h3>
<ul>
<li><code>redis-cli config set save ""</code>：动态停止RDB，save后面给空值，表示禁用保存策略</li>
</ul>
<h2 id="aofappend-of-file">AOF(Append Of File)</h2>
<h3 id="是什么-1">是什么</h3>
<ul>
<li><strong>以日志的形式来记录每个写操作(增量保存)</strong>，将Redis执行过的所有写指令记录下来(读操作不记录)，<strong>只许追加文件，但不改写文件</strong>，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件内容将写指令从前到后执行一次以完成数据恢复工作。</li>
</ul>
<h3 id="如何执行-1">如何执行</h3>
<ol type="1">
<li>客户端的请求写命令会被<strong>追加到AOF缓冲区</strong>内</li>
<li>AOF缓冲区根据AOF持久化策略(always/everysec/no)将操作<strong>同步到磁盘的AOF文件</strong>中</li>
<li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量</li>
<li>Redis服务重启时，会重新加载AOF文件中的写操作达到数据恢复的目的</li>
</ol>
<h3 id="appendonly开启aof">appendonly：开启AOF</h3>
<ul>
<li>AOF默认是不开启的，需要在配置文件中配置<code>appendonly yes</code></li>
<li>可以在redis.conf中配置文件名称，默认是：<code>appendfilename "appendonly.aof"</code></li>
<li>AOF文件的保存路径与RDB的路径一致</li>
<li><strong>如果AOF和RDB同时开启，Redis默认取AOF的数据</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># dramatic event like a server power outage, or a single write if something</span><br><span class="line"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="line"># still running correctly.</span><br><span class="line">#</span><br><span class="line"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line"># with the better durability guarantees.</span><br><span class="line">#</span><br><span class="line"># Please check http://redis.io/topics/persistence for more information.</span><br><span class="line">appendonly no</span><br><span class="line"># The name of the append only file (default: &quot;appendonly.aof&quot;)</span><br><span class="line"></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure>
<h3 id="appendfsync同步频率">appendfsync：同步频率</h3>
<ul>
<li>always：表示始终同步，每次Redis的写入都会立刻记入日志，性能较差但数据完整性好</li>
<li>everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失</li>
<li>no：不主动进行同步，将同步时间交操作系统</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># it wants, for better performances (but if you can live with the idea of</span><br><span class="line"># some data loss consider the default persistence mode that&#x27;s snapshotting),</span><br><span class="line"># or on the contrary, use &quot;always&quot; that&#x27;s very slow but a bit safer than</span><br><span class="line"># everysec.</span><br><span class="line">#</span><br><span class="line"># More details please check the following article:</span><br><span class="line"># http://antirez.com/post/redis-persistence-demystified.html</span><br><span class="line">#</span><br><span class="line"># If unsure, use &quot;everysec&quot;.</span><br><span class="line"></span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>
<h3 id="rewrite压缩">Rewrite压缩</h3>
<h4 id="是什么-2">是什么</h4>
<ul>
<li>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了<strong>重写机制</strong>, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集.可以使用命令<code>bgrewriteaof</code></li>
</ul>
<h4 id="原理">原理</h4>
<ul>
<li>AOF文件持续增长而过大时，会<strong>fork出一条新进程</strong>来将文件重写(也是先写临时文件最后再rename)，<strong>redis4.0版本后的重写，是指上就是把rdb 的快照，以二进制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作</strong></li>
<li><code>no-appendfsync-on-rewrite</code>：
<ul>
<li>如果 <code>no-appendfsync-on-rewrite=yes</code> ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</li>
<li>如果 <code>no-appendfsync-on-rewrite=no</code>, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</li>
</ul></li>
</ul>
<h4 id="触发机制">触发机制</h4>
<ul>
<li>Redis会记录上次重写时的AOF大小，默认配置是当<strong>AOF文件大小是上次rewrite后大小的一倍且文件大于64M</strong>时触发</li>
<li>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写</li>
<li><code>auto-aof-rewrite-percentage</code>：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</li>
<li><code>auto-aof-rewrite-min-size</code>：设置重写的基准值，最小文件64MB。达到这个值开始重写。</li>
<li>如果Redis的**AOF当前大小&gt;= base_size +base_size*100% (默认)且当前大小&gt;=64mb(默认)的情况下**，Redis会对AOF进行重写。</li>
</ul>
<h4 id="重写流程">重写流程</h4>
<ol type="1">
<li><code>bgrewriteaof</code>触发重写，判断是否当前有<code>bgsave</code>或<code>bgrewriteaof</code>在运行，如果有，则等待该命令结束后再继续执行</li>
<li>主进程fork出子进程执行重写操作，保证主进程不会阻塞</li>
<li>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失</li>
<li>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息；主进程把aof_rewrite_buf中的数据写入到新的AOF文件</li>
<li>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写</li>
</ol>
<h3 id="aof备份与恢复">AOF备份与恢复</h3>
<ul>
<li>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</li>
<li>正常恢复：
<ul>
<li>修改默认的<code>appendonly no</code>，改为yes</li>
<li>将有数据的aof文件复制到对应目录</li>
<li>重启redis重新加载</li>
</ul></li>
<li>异常恢复：
<ul>
<li>修改默认的<code>appendonly no</code>，改为yes</li>
<li>如遇到AOF文件操作，通过<code>redis-check-aof --fix appendonly.aof</code>进行恢复</li>
<li>备份被写坏的AOF文件</li>
<li>重启redis重新加载</li>
</ul></li>
</ul>
<h3 id="优劣势">优劣势</h3>
<p>优势：</p>
<ul>
<li>备份机制更稳健，丢失数据概率更低</li>
<li>可读的日志文本，通过操作AOF文件，可以处理误操作</li>
</ul>
<p>劣势：</p>
<ul>
<li>比起RDB占用更多的磁盘空间</li>
<li>恢复备份速度慢</li>
<li>每次读写都同步的话有一定的性能压力</li>
<li>存在个别bug，造成不能恢复</li>
</ul>
<h2 id="如何选择">如何选择</h2>
<ul>
<li>官方推荐两个都启用</li>
<li>如果对数据不敏感，可以选单独用RDB。</li>
<li>不建议单独用 AOF，因为可能会出现Bug。</li>
<li>如果只是做纯内存缓存，可以都不用。</li>
</ul>
<h1 id="redis6的主从复制">Redis6的主从复制</h1>
<ul>
<li>主从复制是指主机数据更新后根据配置和策略，自动同步到备机的<strong>master/slave机制</strong>，<font color="red"><strong>Master以写为主，Slave以读为主</strong></font></li>
<li>作用：
<ul>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
</ul></li>
</ul>
<h2 id="案例">案例</h2>
<ol type="1">
<li><p>假设有三个redis服务器：</p>
<ul>
<li><p>redis6379.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure></li>
<li><p>redis6380.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br></pre></td></tr></table></figure></li>
<li><p>redis6381.conf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">port 6381</span><br><span class="line">dbfilename dump6381.rdb</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>启动三台redis服务器</p></li>
<li><p>查看系统进程检查启动情况</p></li>
<li><p>在redis-cli中通过<code>info replication</code>查看主从复制相关信息</p></li>
<li><p>配置从库(<strong>配从不配主</strong>)</p>
<ol type="1">
<li>通过<code>slaveof &lt;ip&gt; &lt;port&gt;</code>分别配置从服务器6380和6381，具体命令为：<code>slaveof 127.0.0.1 6379</code></li>
<li>测试，在主机上写，可以在从机上读到对应的数据</li>
<li>如果主机挂掉，则重启即可</li>
<li>如果从机挂掉，则需要重新设置：<code>slaveof 127.0.0.1 6379</code>，也可以将其添加到配置文件使其永久有效</li>
</ol></li>
</ol>
<h2 id="常用的三种方式">常用的三种方式</h2>
<h3 id="一主二仆">1. 一主二仆</h3>
<h3 id="薪火相传">2. 薪火相传</h3>
<ul>
<li>上一个slave可以是下一个slave的master，slave同样可以接收其它slave的连接和同步请求，可以有效减轻原master的写压力，去中心化降低风险</li>
</ul>
<blockquote>
<p>方式：<code>slaveof &lt;ip&gt; &lt;port&gt;</code></p>
<p>问题：</p>
<ul>
<li>中途若变更转向，会清除之前的数据，重新建立最新的</li>
<li>一旦某个slave宕机，后面的slave都无法备份</li>
<li>主机挂了，从机还是从机，无法写数据了</li>
</ul>
</blockquote>
<h3 id="反客为主">3. 反客为主</h3>
<ul>
<li>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改</li>
<li>方法：通过命令<code>slaveof no one</code>，将对应从机变为主机</li>
</ul>
<h2 id="复制原理">复制原理</h2>
<ul>
<li>slave启动成功连接到master后会发送一个sync命令</li>
<li>master收到命令后启动后台的存盘进程，同时收集所有接收的用于修改数据集命令，在后台进程执行完毕后，master将传送整个数据文件到Slave以完成一次完全同步</li>
<li>全量复制：slave服务器在接收到数据库文件数据后，将其存盘并加载到内存中</li>
<li>增量复制：master继续将新的所有收集到的修改命令依次传给slave，完成同步</li>
<li>但是只要是重新连接master，一次完全同步(全量复制)将被自动执行</li>
</ul>
<h2 id="哨兵模式sentinel">哨兵模式(sentinel)</h2>
<ul>
<li>哨兵模式是常用的三种方式中的<strong>反客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</li>
</ul>
<h3 id="使用步骤案例">使用步骤(案例)</h3>
<ol type="1">
<li>仍然以三个服务为例，分别是6379(主机)，6380(从机)，6381(从机)</li>
<li>自定义的redis目录下建立<strong>sentinel.conf</strong>文件</li>
<li>配置哨兵：在配置文件中添加<code>sentinel monitor mymaster 127.0.0.1 6379 1</code>，其中<code>mymaster</code>为监控对象起的服务器名称，<code>1</code>表示至少有1个哨兵同意迁移</li>
<li>启动哨兵，对应命令：<code>redis-sentinel myredis/sentinel.conf</code></li>
<li>当主机挂掉时，会从从机中选举产生新的主机，选举标准是根据优先级别(slave-priority)，而原来的主机如果再重启恢复，则会再变成从机</li>
</ol>
<h2 id="复制延时">复制延时</h2>
<ul>
<li>由于所有的写操作都是先在master上操作，然后同步更新到slave上，所以从master同步到slave机器有一定的延时，当系统很繁忙时，延迟问题会更加严重，slave机器数量的增加也会使得这个问题更加严重</li>
</ul>
<h2 id="故障恢复">故障恢复</h2>
<p><img src="http://image.zephon.ml/image-20220823232807718.png" /></p>
<ul>
<li>优先级在redis.conf中默认：<code>slave-priority 100</code>，值越小优先级越高</li>
<li>偏移量最大是指获得原主机数据最全的</li>
<li>每个redis实例启动后都会随机产生一个40位的runid</li>
</ul>
<h1 id="redis6集群">Redis6集群</h1>
<h2 id="简介-1">简介</h2>
<blockquote>
<p>集群要解决的问题：</p>
<p>容量不够时，Redis如何扩容？</p>
<p>并发写操作时，Redis如何分摊？</p>
<p>此外，主从复制各种模式下主机宕机导致IP地址发生变化，应用程序中配置需求修改对应的主机地址、端口等信息。</p>
<p>针对这些，Redis3.0提供了解决方案，就是<strong>无中心化集群</strong>配置：</p>
<ul>
<li>相当于每个主机都是代理主机，都能作为集群入口</li>
</ul>
</blockquote>
<p>什么是Redis集群？</p>
<ul>
<li><p>Redis集群实现了对Redis的水平扩容，即启动N个Redis节点，将整个数据库分布存储在N个节点中，每个节点存储总数据的1/N</p></li>
<li><p>Redis集群通过分区(partion)来提供一定程度的可用性(availability)，即使集群中有一部分节点失效或无法通讯，集群也可以继续处理命令请求。</p></li>
</ul>
<h2 id="案例-1">案例</h2>
<blockquote>
<p>以6个主机为例，3主3从，假设对应的是：192.168.1.2，192.168.1.3，192.168.1.4，192.168.1.5，192.168.1.6，192.168.1.7</p>
</blockquote>
<h3 id="配置基本信息">1、配置基本信息</h3>
<blockquote>
<p>开启daemonize yes</p>
<p>Pid文件名字</p>
<p>指定端口</p>
<p>Log文件名字</p>
<p>Dump.rdb名字</p>
<p>Appendonly 关掉或者换名字</p>
</blockquote>
<h3 id="redis-cluster配置修改">2、redis cluster配置修改</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include /home/bigdata/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">pidfile &quot;/var/run/redis_6379.pid&quot;</span><br><span class="line">dbfilename &quot;dump6379.rdb&quot;</span><br><span class="line">dir &quot;/home/zephon/redis_cluster&quot;</span><br><span class="line">logfile &quot;/home/zephon/redis_cluster/redis_err_6379.log&quot;</span><br><span class="line">cluster-enabled yes # 打开集群模式</span><br><span class="line">cluster-config-file nodes-6379.conf # 设定节点配置文件名</span><br><span class="line">cluster-node-timeout 15000 #  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：需要将修改好的redis.conf复制到不同主机上</p>
</blockquote>
<h3 id="启动6个主机的服务">3、启动6个主机的服务</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>
<h3 id="将6个节点合成一个集群">4、将6个节点合成一个集群</h3>
<blockquote>
<p>组合之前要确保所有redis服务已启动，nodes-xxx.conf文件生成正常</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster --replicas 1 192.168.1.2:6379 192.168.1.3:6379 192.168.1.4:6379 192.168.1.5:6379 192.168.1.6:6379 192.168.1.7:6379</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，这里的IP需要用真实IP，不能用127.0.0.1</p>
<p><font color="red">--replicas 1</font>：表示采用最简单的方式配置集群，一台主机一台从机，正好三组</p>
</blockquote>
<h3 id="集群策略连接">5、集群策略连接</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 6379</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>-c</code>采用集群策略连接，设置数据会自动切换到相应的写主机</li>
</ul>
<h3 id="查看集群信息">6、查看集群信息</h3>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>
<h2 id="集群节点分配">集群节点分配</h2>
<ul>
<li>一个集群至少要有<strong>三个主节点</strong></li>
<li>选项<code>--cluster-replicas 1</code>表示希望为集群中的每个主节点创建一个从节点</li>
<li>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址</li>
</ul>
<h2 id="slots">slots</h2>
<ul>
<li>一个Redis集群包含16384个插槽(hash slot)，数据库中的每个键都属于这16384个插槽的其中一个</li>
<li>集群使用公式<strong>CRC16(key)%16384</strong>来计算键key属于哪个槽，其中<strong>CRC16(key)</strong>用于计算key的CRC16校验和</li>
<li>集群中的每个节点负责处理一部分插槽。</li>
</ul>
<h2 id="集群中值的录入与查询">集群中值的录入与查询</h2>
<h3 id="录入">录入</h3>
<ul>
<li>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知前往的redis实例地址和端口</li>
<li>redis-cli客户端提供了<code>-c</code>参数实现自动重定向
<ul>
<li>如<code>redis-cli -c -p 6379</code>登入后，再录入、查询键值对可以自动重定向</li>
</ul></li>
<li>不在一个slot下的键值，是不能<strong>使用mget、mset等多键操作</strong></li>
<li>可以通过<code>&#123;&#125;</code>来定义组的概念，从而使key中<code>&#123;&#125;</code>内相同内容的键值对放到一个slot中去
<ul>
<li>如：<code>mset name&#123;user&#125; v1 age&#123;user&#125; v2 address&#123;user&#125; v3</code></li>
</ul></li>
</ul>
<h3 id="查询">查询</h3>
<ul>
<li><code>cluster getkeysinslot &lt;slot&gt; &lt;count&gt;</code>：返回count个slot槽中的键</li>
<li><code>cluster keyslot &lt;group&gt;</code>：返回<code>&#123;group&#125;</code>中对应组的slot槽</li>
<li><code>cluster countkeysinslot &lt;slot&gt;</code>：返回slot槽中键的数量</li>
</ul>
<h2 id="故障恢复-1">故障恢复</h2>
<ul>
<li>如果某一段插槽的主从都挂掉，而<code>cluster-require-full-coverage</code>为yes，则整个集群都挂掉</li>
<li>如果某一段插槽的主从都挂掉，而<code>cluster-require-full-coverage</code>为no，则<strong>该</strong>插槽数据全部不能使用，也无法存储</li>
</ul>
<h2 id="redis集群的优劣">Redis集群的优劣</h2>
<p>优势：</p>
<ul>
<li>实现扩容</li>
<li>分摊压力</li>
<li>无中心配置相对简单</li>
</ul>
<p>劣势：</p>
<ul>
<li>多键操作不被支持</li>
<li>多键的Redis事务不被支持，lua脚本不被支持</li>
<li>由于Redis集群方案出现较晚，很多公司已经用了其它集群方案，而代理或客户端分片的方案想<strong>迁移</strong>到redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</li>
</ul>
<h1 id="redis6应用问题解决">Redis6应用问题解决</h1>
<h2 id="缓存穿透">缓存穿透</h2>
<h3 id="问题描述">问题描述</h3>
<p>key对应的数据在数据源并不存在，每次针对key的请求从缓存中获取不到，请求都会压到数据源，从而可能压垮数据源。如用一个不存在的用户id获取用户信息，无论缓存还是数据库都没有，若黑客利用此漏洞攻击可能压垮数据库。</p>
<h3 id="解决方案">解决方案</h3>
<p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存意义。</p>
<p>解决方案：</p>
<ol type="1">
<li><p><strong><font color="red">对空值缓存</font></strong>：如果一个查询返回的数据为空(不管数据是否不存在)，都将这个空结果(null)进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p></li>
<li><p><strong><font color="red">设置可访问的名单(白名单)</font></strong>：使用bitmaps类型定义一个可访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问</p></li>
<li><p><strong><font color="red">采用布隆过滤器</font></strong>：布隆过滤器(Bloom Filter)是1970年由布隆提出的。实际上是一个很长的二进制向量(位图)和一系列随机映射函数(哈希函数)。可以<strong>用于检索一个元素是否在一个集合中</strong>。它的优点是空间效率和查询时间都远远超过一般算法，缺点是有一定的误识别率和删除困难。</p>
<p>将所有可能存在的数据哈希到一个足够大的Bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力</p></li>
<li><p><strong><font color="red">进行实时监控</font></strong>：当发现redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p></li>
</ol>
<h2 id="缓存击穿">缓存击穿</h2>
<h3 id="问题描述-1">问题描述</h3>
<p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并设回到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<h3 id="解决方案-1">解决方案</h3>
<p>key可能会在某些时间点被超高并发地访问，是一种非常"热点"的数据。这个时候需要考虑一个问题：缓存被“击穿”的问题</p>
<p>解决问题：</p>
<ol type="1">
<li><strong><font color="red">预先设置热门数据</font></strong>：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</li>
<li><strong><font color="red">实时调整</font></strong>：现场监控哪些数据热门，实时调整key的过期时长</li>
<li><strong><font color="red">使用锁</font></strong>：
<ol type="1">
<li>在缓存失效的时候(判断拿出来的值为空)，不是立即去load db</li>
<li>而是先使用缓存工具的某些带成功操作返回值的操作(如redis的<code>setnx</code>)去set一个mutex key</li>
<li>当操作返回成功时，再进行load db的操作，并回设缓存，最后删除mutex key</li>
<li>当操作返回失败时，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法</li>
</ol></li>
</ol>
<h2 id="缓存雪崩">缓存雪崩</h2>
<h3 id="问题描述-2">问题描述</h3>
<p>key对应数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于缓存雪崩针对很多key缓存，前者则是某一个key</p>
<h3 id="解决方案-2">解决方案</h3>
<ol type="1">
<li><strong><font color="red">构建多级缓存架构</font></strong>：nginx缓存+redis缓存+其它缓存(ehcache等)</li>
<li><strong><font color="red">使用锁或队列</font></strong>：用加锁或队列的方式保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，不适用于高并发情况</li>
<li><strong><font color="red">设置过期标志更新缓存</font></strong>：记录缓存数据是否过期(设置提前量)，如果过期会触发通知另外的线程在后台去更新实际key的缓存</li>
<li><strong><font color="red">将缓存失效时间分散开</font></strong>：比如可以在原有的失效时间基础上增加一个随机值，如1~5分钟随机，这样每个缓存的过期时间的重复率应付降低，就很难引发集体失效的事件</li>
</ol>
<h2 id="分布式锁">分布式锁</h2>
<h3 id="问题描述-3">问题描述</h3>
<p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器 上，使得原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题</p>
<p>分布式锁主流的实现方案：</p>
<ol type="1">
<li>基于数据库实现分布式锁</li>
<li>基于缓存(Redis等)</li>
<li>基于Zookeeper</li>
</ol>
<p>每种分布式锁解决方案都有各自的优缺点：</p>
<ul>
<li>性能：Redis最高</li>
<li>可靠性：zookeeper最高</li>
</ul>
<h3 id="解决方案使用redis实现分布式锁">解决方案：使用Redis实现分布式锁</h3>
<ul>
<li><code>setnx lock 1</code>：上锁</li>
<li><code>del lock</code>：释放锁</li>
</ul>
<p><img src="http://image.zephon.ml/image-20220904100930848.png" /></p>
<ol type="1">
<li>多个客户端同时获取锁(setnx)</li>
<li>获取成功，执行业务逻辑(从db获取数据，放入缓存)，执行完成释放锁(del)</li>
<li>其它客户端等待重试</li>
</ol>
<p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p>
<p>解决：设置过期时间，自动释放锁</p>
<h3 id="优化-设置锁的过期时间">优化-设置锁的过期时间</h3>
<ul>
<li><p>通过<code>expire</code>设置过期时间(缺乏原子性，如果在<code>setnx</code>和<code>expire</code>之间出现异常，锁也无法释放)</p></li>
<li><p>在<code>set</code>时指定过期时间(推荐)</p></li>
<li><p><code>set lock 1 NX EX 12</code>：设置锁的同时设置过期时间为12秒</p>
<ul>
<li><code>EX</code>：表示过期时间的单位是秒</li>
<li><code>PX</code>：表示过期时间的单位是毫秒</li>
</ul></li>
</ul>
<p>问题：可能会释放其它服务器的锁</p>
<p>解决：<code>setnx</code>获取锁时，设置一个指定的唯一值(如：UUID)，释放前获取这个值，判断是否是自己的锁</p>
<h3 id="优化-uuid防误删">优化-UUID防误删</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取锁,3秒后过期，使用UUID防止误删，uuid表示不同的操作</span></span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 2. 判断锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">            Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">// 更新值</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">            <span class="comment">// 释放锁时，判断当前uuid和释放锁uuid是否一样，如果一样才释放</span></span><br><span class="line">            <span class="keyword">if</span>(uuid.equals(redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>)))&#123;</span><br><span class="line">                redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 获取锁失败</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                testLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：删除操作缺乏原子性</p>
<p>解决：使用LUA脚本保证删除的原子性</p>
<h3 id="优化-lua脚本保证删除的原子性">优化-LUA脚本保证删除的原子性</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取锁,3秒后过期，使用UUID防止误删，uuid表示不同的操作</span></span><br><span class="line">        String uuid = UUID.randomUUID().toString();</span><br><span class="line">        Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 2. 判断锁</span></span><br><span class="line">        <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">            Object value = redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">// 更新值</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">            <span class="comment">// 释放锁时，判断当前uuid和释放锁uuid是否一样，如果一样才释放</span></span><br><span class="line">            <span class="keyword">if</span>(uuid.equals(redisTemplate.opsForValue().get(<span class="string">&quot;lock&quot;</span>)))&#123;</span><br><span class="line">                String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1])==ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">                DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">                redisScript.setScriptText(script);</span><br><span class="line">                redisScript.setResultType(Long.class);</span><br><span class="line">                redisTemplate.execute(redisScript, Arrays.asList(<span class="string">&quot;lock&quot;</span>), uuid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 获取锁失败</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                testLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ol type="1">
<li>加锁</li>
<li>使用lua释放锁</li>
<li>重试</li>
</ol>
<p>为确保分布式锁可用，至少要确保锁的实现同时满足以下四个条件：</p>
<ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其它客户端能加锁</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</li>
<li>加锁和解锁必须具有原子性</li>
</ul>
<h1 id="redis6新特性">Redis6新特性</h1>
<h2 id="redis6新数据类型">Redis6新数据类型</h2>
<h3 id="bitmaps">Bitmaps</h3>
<h4 id="介绍">介绍</h4>
<ul>
<li>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作，
<ul>
<li>Bitmaps本身不是一种数据类型，实际上它就是字符串(key-value)，但是它可以对字符串的位进行操作
<ul>
<li>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量</li>
</ul></li>
</ul></li>
</ul>
<h4 id="相关命令-1">相关命令</h4>
<ul>
<li><code>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;</code>：设置Bitmaps中某个偏移量的值(0或1)
<ul>
<li>offset：偏移量从0开始</li>
<li>如果第一次初始化时指定的偏移量很大，会造成redis的性能下降</li>
</ul></li>
<li><code>getbit &lt;key&gt; &lt;offset&gt;</code>：获取Bitmaps中某个偏移量的值</li>
<li><code>bitcount</code>：统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的start或end参数，可以让计数只在特定的位上进行，start和end参数的设置，都可以使用负数值：如-1表示最后一位，而-2表示倒数第二位，start和end是指bit组的字节的下标数，二者皆包含。
<ul>
<li><code>bitcount &lt;key&gt; [start end]</code>：统计字符串从start字节到end字节<strong>比特值</strong>为1的数量，即每次统计的是至少8位</li>
</ul></li>
<li><code>bitop and(or/not/xor) &lt;destkey&gt; [key...]</code>：bitop是一个复合操作，可以做多个Bitmaps的and(与)、or(或)、not(非)、xor(异或)操作并将结果保存在destkey中</li>
</ul>
<h3 id="hyperloglog">HyperLogLog</h3>
<h4 id="介绍-1">介绍</h4>
<ul>
<li><p>在开发中，经常会遇到与统计相关的功能需求，如统计网站PV(PageVIew页面访问量)，可以使用Redis的incr、incrby轻松实现</p></li>
<li><p>但像UV(UniqueVisitor，独立访客)、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p></li>
<li><p>解决基数问题有很多方案：</p>
<ol type="1">
<li>数据存储在MySQL表中，使用distinct、count计算不重复个数</li>
<li>使用Redis提供的hash、set、bitmaps等数据结构来处理</li>
</ol>
<p>这些方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的</p></li>
<li><p>Redis推出了HyperLogLog，HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是在输入元素或者体积非常非常大时，计算基数所需的空间总是固定的，并且是很小的。</p></li>
<li><p>在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以直接计算接近<span class="math inline">\(2^{64}\)</span>个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比</p></li>
<li><p>但是，因为HyperLogLog只会根据输入元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素</p>
<ul>
<li><p>什么是基数？</p>
<p>如数据集{1,3,5,7,5,7,8}，则这个数据集的基数集为{1,3,5,7,8}，基数(不重复元素)为5，基数估计就是在误差可接受范围内，快速计算基数</p></li>
</ul></li>
</ul>
<h4 id="相关命令-2">相关命令</h4>
<ul>
<li><code>pfadd &lt;key&gt; &lt;element&gt; [element ...]</code>：添加指定元素到HyperLogLog中，如果执行命令后近似基数发生变化，则返回1，否则返回0</li>
<li><code>pfcount &lt;key&gt; [key ...]</code>：统计近似基数值</li>
<li><code>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey...]</code>：将一个或多个HyperLogLog合并后的结果存在另一个HyperLogLog</li>
</ul>
<h3 id="geospatial">Geospatial</h3>
<h4 id="介绍-2">介绍</h4>
<ul>
<li>Redis 3.2中增加了对GEO类型的支持，GEO(Geographic)，地理信息的缩写。该类型就是元素的二维坐标，在地图上就是经纬度。Redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作</li>
</ul>
<h4 id="相关命令-3">相关命令</h4>
<ul>
<li><p><code>geoadd &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; &lt;member&gt; [longitude latitude member ...]</code>：添加地理位置(经度，纬度，名称)</p>
<blockquote>
<p>注：两极无法直接添加</p>
<p>有效的经度从-180度到180度；有效的纬度从-85.05112878度到85.05112878度，当坐标超出指定范围是，该命令将会返回一个错误，已经添加的数据是无法再往里面添加的</p>
</blockquote></li>
<li><p><code>geopos &lt;key&gt; &lt;member&gt; [member...]</code>：获得指定地区的坐标值</p></li>
<li><p><code>geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt; [m|km|ft|mi]</code>：获取两个位置之间的直线距离</p>
<ul>
<li>m：单位米(默认)</li>
<li>km：单位千米</li>
<li>mi：单位英里</li>
<li>ft：单位英尺</li>
</ul></li>
<li><p><code>georadius &lt;key&gt; &lt;longitude&gt; &lt;latitude&gt; radius m|km|ft|mi</code>：以给定经纬度为中心，找出某一半径内的元素</p></li>
</ul>
<h2 id="redis6新功能">Redis6新功能</h2>
<h3 id="acl">ACL</h3>
<ul>
<li>Redis ACL是Access Control List(访问控制列表)的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接</li>
<li>在Redis5之前，Redis安全规则只有密码控制，还有通过rename来调整高危命令比如<code>flushdb</code>，<code>keys *</code>，<code>shutdown</code>等。Redis6则提供ACL的功能对用户进行更细粒度的权限控制：
<ol type="1">
<li>接入权限：用户名和密码</li>
<li>可以执行的命令</li>
<li>可以操作的key</li>
</ol></li>
</ul>
<h4 id="相关命令-4">相关命令</h4>
<ul>
<li><code>acl list</code>：查看用户权限列表
<ul>
<li><code>user default on nopass ~* &amp;* +@all</code>：<code>user default</code>：用户；<code>on</code>：启用该用户；<code>nopass</code>：没有密码；<code>~* &amp;*</code>：能操作哪些key；<code>+@all</code>：能操作哪些命令</li>
</ul></li>
<li><code>acl cat</code>：查看权限指令类别
<ul>
<li>加参数类型名可以查看类型下具体命令，如：<code>acl cat string</code></li>
</ul></li>
<li><code>acl whoami</code>：查看当前用户</li>
<li><code>aclsetuser</code>：创建和编辑用户ACL
<ul>
<li>启用/禁用：<code>on/off</code></li>
<li>权限添加删除：
<ul>
<li><code>+&lt;command&gt;</code>、<code>-&lt;command&gt;</code>：向用户可执行指令列表中添加或移除命令</li>
<li>`<code>+@&lt;category&gt;</code>、<code>-@&lt;category&gt;</code>：从用户可调用指令中添加或移除类别</li>
<li><code>allcommands</code>、<code>nocommand</code>：<code>+@all</code>、<code>-@all</code>的别名</li>
</ul></li>
<li>可操作键的添加或删除：
<ul>
<li><code>~&lt;pattern&gt;</code>：添加可作为用户可操作的键的模式，如<code>~*</code>允许所有的键</li>
</ul></li>
</ul></li>
<li>例：
<ul>
<li>通过命令创建新用户默认权限：<code>acl setuser tom</code></li>
<li>设置用户名、密码、ACL权限、并启用的用户：<code>acl setuser tom on &gt;mypassword ~cached:* +get</code></li>
<li>登录用户：<code>auth tom mypassword</code></li>
</ul></li>
</ul>
<h3 id="io多线程">IO多线程</h3>
<ul>
<li><p>IO多线程其实指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线程。</p></li>
<li><p>执行命令仍然是单线程</p></li>
<li><p>多线程IO默认是不开启的，需要在配置文件中配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads yes</span><br><span class="line">io-threads 4</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="工具支持cluster">工具支持Cluster</h3>
<ul>
<li>官方redis-benchmark工具开始支持cluster模式，通过多线程的方式对多个分片进行压测</li>
</ul>
<h3 id="其它-1">其它</h3>
<ol type="1">
<li><p>RESP3新的通信协议：优化服务端与客户端之间的通信</p></li>
<li><p>Client site caching客户端缓存：基于RESP3协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互</p></li>
<li><p>Proxy集群代理模式：Proxy功能，让Cluster拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变Cluster的功能限制，不支持的命令还是不会支持，如跨slot的多key操作</p></li>
<li><p>Modules API</p>
<p>Redis6中模块API开发进展非常大。</p></li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Zephon
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://www.zephon.eu.org/blog/2022/09/10/Redis%E6%B1%87%E6%80%BB/" title="Redis汇总">http://www.zephon.eu.org/blog/2022/09/10/Redis汇总/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/blog/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag"><i class="fa fa-tag"></i> 中间件</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2022/09/01/%E5%8A%A8%E6%80%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%A0%E7%AF%87%E8%AE%BA%E6%96%87/" rel="prev" title="动态神经网络相关的几篇论文">
      <i class="fa fa-chevron-left"></i> 动态神经网络相关的几篇论文
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2022/09/11/SpringBoot-%E6%A0%B8%E5%BF%83-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" rel="next" title="SpringBoot 核心-基础入门">
      SpringBoot 核心-基础入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80MDY3OS8xNzIwNA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#nosql"><span class="nav-number">1.</span> <span class="nav-text">NoSQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">技术的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.</span> <span class="nav-text">多服务器问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#session%E5%AD%98%E5%9C%A8%E5%93%AA"><span class="nav-number">1.2.1.</span> <span class="nav-text">session存在哪？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3io%E5%8E%8B%E5%8A%9B"><span class="nav-number">1.2.2.</span> <span class="nav-text">解决IO压力</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nosql%E6%A6%82%E8%BF%B0"><span class="nav-number">1.3.</span> <span class="nav-text">NoSQL概述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">Redis6概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">2.2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">安装目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8"><span class="nav-number">2.3.</span> <span class="nav-text">启动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E5%8F%B0%E5%90%AF%E5%8A%A8%E4%B8%8D%E6%8E%A8%E8%8D%90"><span class="nav-number">2.3.1.</span> <span class="nav-text">前台启动(不推荐)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%E6%8E%A8%E8%8D%90"><span class="nav-number">2.3.2.</span> <span class="nav-text">后台启动(推荐)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">2.4.</span> <span class="nav-text">其它</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">五大数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">3.1.</span> <span class="nav-text">相关命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2string"><span class="nav-number">3.2.</span> <span class="nav-text">字符串(String)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">3.2.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.2.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8list"><span class="nav-number">3.3.</span> <span class="nav-text">列表(List)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">3.3.2.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88set"><span class="nav-number">3.4.</span> <span class="nav-text">集合(Set)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="nav-number">3.4.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2"><span class="nav-number">3.4.2.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8Chash"><span class="nav-number">3.5.</span> <span class="nav-text">哈希(Hash)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">3.5.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="nav-number">3.5.2.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3"><span class="nav-number">3.5.3.</span> <span class="nav-text">数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset"><span class="nav-number">3.6.</span> <span class="nav-text">有序集合Zset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="nav-number">3.6.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4"><span class="nav-number">3.6.2.</span> <span class="nav-text">数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">4.</span> <span class="nav-text">Redis6配置文件常用配置详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#units-%E5%8D%95%E4%BD%8D"><span class="nav-number">4.1.</span> <span class="nav-text">1、Units 单位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#includes%E5%8C%85%E5%90%AB"><span class="nav-number">4.2.</span> <span class="nav-text">2、INCLUDES包含</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">4.3.</span> <span class="nav-text">3、网络相关配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bind"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.1、bind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected-mode"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.2、protected-mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#port"><span class="nav-number">4.3.3.</span> <span class="nav-text">3.3、 Port</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-backlog"><span class="nav-number">4.3.4.</span> <span class="nav-text">3.4、tcp-backlog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timeout"><span class="nav-number">4.3.5.</span> <span class="nav-text">3.5、timeout</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tcp-keepalive"><span class="nav-number">4.3.6.</span> <span class="nav-text">3.6 tcp-keepalive</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#general%E9%80%9A%E7%94%A8"><span class="nav-number">4.4.</span> <span class="nav-text">4、GENERAL通用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#daemonize"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.1、daemonize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pidfile"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.2、pidfile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loglevel"><span class="nav-number">4.4.3.</span> <span class="nav-text">4.3、loglevel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#logfile"><span class="nav-number">4.4.4.</span> <span class="nav-text">4.4、logfile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#databases-16"><span class="nav-number">4.4.5.</span> <span class="nav-text">4.5、databases 16</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#security%E5%AE%89%E5%85%A8"><span class="nav-number">4.5.</span> <span class="nav-text">5、SECURITY安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81"><span class="nav-number">4.5.1.</span> <span class="nav-text">5.1、设置密码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clients"><span class="nav-number">4.6.</span> <span class="nav-text">6、CLIENTS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#maxclients"><span class="nav-number">4.6.1.</span> <span class="nav-text">6.1、maxclients</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-management"><span class="nav-number">4.7.</span> <span class="nav-text">7、MEMORY MANAGEMENT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#maxmemory"><span class="nav-number">4.7.1.</span> <span class="nav-text">7.1、maxmemory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maxmemory-policy"><span class="nav-number">4.7.2.</span> <span class="nav-text">7.2、maxmemory-policy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maxmemory-samples"><span class="nav-number">4.7.3.</span> <span class="nav-text">7.3、maxmemory-samples</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="nav-number">5.</span> <span class="nav-text">Redis6的发布与订阅</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="nav-number">5.1.</span> <span class="nav-text">什么是发布和订阅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="nav-number">5.2.</span> <span class="nav-text">Redis的发布和订阅</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">5.3.</span> <span class="nav-text">发布订阅相关命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#jedis%E6%93%8D%E4%BD%9Credis6"><span class="nav-number">6.</span> <span class="nav-text">Jedis操作Redis6</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%8C%85"><span class="nav-number">6.1.</span> <span class="nav-text">1、导包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">6.2.</span> <span class="nav-text">2、使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jedis%E5%B8%B8%E7%94%A8api"><span class="nav-number">6.3.</span> <span class="nav-text">Jedis常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#key"><span class="nav-number">6.3.1.</span> <span class="nav-text">Key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">6.3.2.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">6.3.3.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set"><span class="nav-number">6.3.4.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hash"><span class="nav-number">6.3.5.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zset"><span class="nav-number">6.3.6.</span> <span class="nav-text">zset</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#springboot%E6%95%B4%E5%90%88redis"><span class="nav-number">7.</span> <span class="nav-text">SpringBoot整合Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-number">7.1.</span> <span class="nav-text">1、导入依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEapplication.properties"><span class="nav-number">7.2.</span> <span class="nav-text">2、配置application.properties</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0redis%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="nav-number">7.3.</span> <span class="nav-text">3、添加Redis配置类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="nav-number">8.</span> <span class="nav-text">Redis6的事务操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#multiexecdiscard"><span class="nav-number">8.1.</span> <span class="nav-text">multi、exec、discard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">8.2.</span> <span class="nav-text">事务的错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E9%94%81%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">8.3.</span> <span class="nav-text">Redis锁相关命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="nav-number">8.4.</span> <span class="nav-text">Redis事务三特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E4%BA%8B%E5%8A%A1%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B"><span class="nav-number">8.5.</span> <span class="nav-text">Redis事务秒杀案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E7%A7%92%E6%9D%80%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="nav-number">8.5.1.</span> <span class="nav-text">模拟秒杀的工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%9A%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.6.</span> <span class="nav-text">业务实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8lua%E8%A7%A3%E5%86%B3%E5%BA%93%E5%AD%98%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98"><span class="nav-number">8.7.</span> <span class="nav-text">使用Lua解决库存遗留问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lua%E8%84%9A%E6%9C%AC"><span class="nav-number">8.7.1.</span> <span class="nav-text">lua脚本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">Redis6持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rdbredis-database"><span class="nav-number">9.1.</span> <span class="nav-text">RDB(Redis DataBase)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">9.1.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C"><span class="nav-number">9.1.2.</span> <span class="nav-text">如何执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fork"><span class="nav-number">9.1.3.</span> <span class="nav-text">Fork</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="nav-number">9.1.4.</span> <span class="nav-text">相关配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dbfilename"><span class="nav-number">9.1.5.</span> <span class="nav-text">dbfilename</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dir"><span class="nav-number">9.1.6.</span> <span class="nav-text">dir</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">9.1.7.</span> <span class="nav-text">快照触发机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#snapshotting%E5%BF%AB%E7%85%A7"><span class="nav-number">9.1.8.</span> <span class="nav-text">SNAPSHOTTING：快照</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#save"><span class="nav-number">9.1.8.1.</span> <span class="nav-text">save</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stop-writes-on-bgsave-error"><span class="nav-number">9.1.8.2.</span> <span class="nav-text">stop-writes-on-bgsave-error</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdbcompression"><span class="nav-number">9.1.8.3.</span> <span class="nav-text">rdbcompression</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rdbchecksum"><span class="nav-number">9.1.8.4.</span> <span class="nav-text">rdbchecksum</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">9.1.9.</span> <span class="nav-text">备份与恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%87%E4%BB%BD"><span class="nav-number">9.1.9.1.</span> <span class="nav-text">备份</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D"><span class="nav-number">9.1.9.2.</span> <span class="nav-text">恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdb%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="nav-number">9.1.10.</span> <span class="nav-text">RDB优劣势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%BD%BF%E7%94%A8rdb"><span class="nav-number">9.1.11.</span> <span class="nav-text">如何停止使用RDB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#aofappend-of-file"><span class="nav-number">9.2.</span> <span class="nav-text">AOF(Append Of File)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="nav-number">9.2.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C-1"><span class="nav-number">9.2.2.</span> <span class="nav-text">如何执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#appendonly%E5%BC%80%E5%90%AFaof"><span class="nav-number">9.2.3.</span> <span class="nav-text">appendonly：开启AOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#appendfsync%E5%90%8C%E6%AD%A5%E9%A2%91%E7%8E%87"><span class="nav-number">9.2.4.</span> <span class="nav-text">appendfsync：同步频率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rewrite%E5%8E%8B%E7%BC%A9"><span class="nav-number">9.2.5.</span> <span class="nav-text">Rewrite压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="nav-number">9.2.5.1.</span> <span class="nav-text">是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">9.2.5.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">9.2.5.3.</span> <span class="nav-text">触发机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">9.2.5.4.</span> <span class="nav-text">重写流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aof%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">9.2.6.</span> <span class="nav-text">AOF备份与恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="nav-number">9.2.7.</span> <span class="nav-text">优劣势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-number">9.3.</span> <span class="nav-text">如何选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">10.</span> <span class="nav-text">Redis6的主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">10.1.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">10.2.</span> <span class="nav-text">常用的三种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86"><span class="nav-number">10.2.1.</span> <span class="nav-text">1. 一主二仆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="nav-number">10.2.2.</span> <span class="nav-text">2. 薪火相传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="nav-number">10.2.3.</span> <span class="nav-text">3. 反客为主</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">10.3.</span> <span class="nav-text">复制原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8Fsentinel"><span class="nav-number">10.4.</span> <span class="nav-text">哨兵模式(sentinel)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%E6%A1%88%E4%BE%8B"><span class="nav-number">10.4.1.</span> <span class="nav-text">使用步骤(案例)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6"><span class="nav-number">10.5.</span> <span class="nav-text">复制延时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="nav-number">10.6.</span> <span class="nav-text">故障恢复</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E9%9B%86%E7%BE%A4"><span class="nav-number">11.</span> <span class="nav-text">Redis6集群</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">11.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="nav-number">11.2.</span> <span class="nav-text">案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="nav-number">11.2.1.</span> <span class="nav-text">1、配置基本信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-cluster%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9"><span class="nav-number">11.2.2.</span> <span class="nav-text">2、redis cluster配置修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A86%E4%B8%AA%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="nav-number">11.2.3.</span> <span class="nav-text">3、启动6个主机的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%866%E4%B8%AA%E8%8A%82%E7%82%B9%E5%90%88%E6%88%90%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4"><span class="nav-number">11.2.4.</span> <span class="nav-text">4、将6个节点合成一个集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%AD%96%E7%95%A5%E8%BF%9E%E6%8E%A5"><span class="nav-number">11.2.5.</span> <span class="nav-text">5、集群策略连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E4%BF%A1%E6%81%AF"><span class="nav-number">11.2.6.</span> <span class="nav-text">6、查看集群信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E5%88%86%E9%85%8D"><span class="nav-number">11.3.</span> <span class="nav-text">集群节点分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slots"><span class="nav-number">11.4.</span> <span class="nav-text">slots</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%80%BC%E7%9A%84%E5%BD%95%E5%85%A5%E4%B8%8E%E6%9F%A5%E8%AF%A2"><span class="nav-number">11.5.</span> <span class="nav-text">集群中值的录入与查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%95%E5%85%A5"><span class="nav-number">11.5.1.</span> <span class="nav-text">录入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2"><span class="nav-number">11.5.2.</span> <span class="nav-text">查询</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D-1"><span class="nav-number">11.6.</span> <span class="nav-text">故障恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%BC%98%E5%8A%A3"><span class="nav-number">11.7.</span> <span class="nav-text">Redis集群的优劣</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="nav-number">12.</span> <span class="nav-text">Redis6应用问题解决</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">12.1.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">12.1.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">12.1.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">12.2.</span> <span class="nav-text">缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">12.2.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-number">12.2.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">12.3.</span> <span class="nav-text">缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="nav-number">12.3.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="nav-number">12.3.2.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">12.4.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3"><span class="nav-number">12.4.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">12.4.2.</span> <span class="nav-text">解决方案：使用Redis实现分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-%E8%AE%BE%E7%BD%AE%E9%94%81%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">12.4.3.</span> <span class="nav-text">优化-设置锁的过期时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-uuid%E9%98%B2%E8%AF%AF%E5%88%A0"><span class="nav-number">12.4.4.</span> <span class="nav-text">优化-UUID防误删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96-lua%E8%84%9A%E6%9C%AC%E4%BF%9D%E8%AF%81%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">12.4.5.</span> <span class="nav-text">优化-LUA脚本保证删除的原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">12.4.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#redis6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">13.</span> <span class="nav-text">Redis6新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redis6%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.1.</span> <span class="nav-text">Redis6新数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bitmaps"><span class="nav-number">13.1.1.</span> <span class="nav-text">Bitmaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">13.1.1.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-1"><span class="nav-number">13.1.1.2.</span> <span class="nav-text">相关命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hyperloglog"><span class="nav-number">13.1.2.</span> <span class="nav-text">HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">13.1.2.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-2"><span class="nav-number">13.1.2.2.</span> <span class="nav-text">相关命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#geospatial"><span class="nav-number">13.1.3.</span> <span class="nav-text">Geospatial</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">13.1.3.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-3"><span class="nav-number">13.1.3.2.</span> <span class="nav-text">相关命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis6%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="nav-number">13.2.</span> <span class="nav-text">Redis6新功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acl"><span class="nav-number">13.2.1.</span> <span class="nav-text">ACL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4-4"><span class="nav-number">13.2.1.1.</span> <span class="nav-text">相关命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">13.2.2.</span> <span class="nav-text">IO多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81cluster"><span class="nav-number">13.2.3.</span> <span class="nav-text">工具支持Cluster</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83-1"><span class="nav-number">13.2.4.</span> <span class="nav-text">其它</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zephon"
      src="/blog/images/avatar1.gif">
  <p class="site-author-name" itemprop="name">Zephon</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives">
          <span class="site-state-item-count">217</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Zephon-H" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Zephon-H" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/blog/qq1528498238@gmail.com" title="E-Mail → qq1528498238@gmail.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zephon</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">20:18</span>
</div>

<br />
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/21/2019 15:54:40");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
